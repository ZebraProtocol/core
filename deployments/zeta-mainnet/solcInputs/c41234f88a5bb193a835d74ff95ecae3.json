{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/core/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/IZebraUSD.sol\";\nimport \"../dependencies/ZebraBase.sol\";\nimport \"../dependencies/ZebraMath.sol\";\nimport \"../dependencies/ZebraOwnable.sol\";\nimport \"../dependencies/DelegatedOps.sol\";\nimport \"../dependencies/console.sol\";\n\n/**\n    @title Zebra Borrower Operations\n    @notice Based on Liquity's `BorrowerOperations`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/BorrowerOperations.sol\n\n            Zebra's implementation is modified to support multiple collaterals. There is a 1:n\n            relationship between `BorrowerOperations` and each `TroveManager` / `SortedTroves` pair.\n */\ncontract BorrowerOperations is IBorrowerOperations, ZebraBase, ZebraOwnable, DelegatedOps {\n\tusing SafeERC20 for IERC20;\n\n\tIZebraUSD public immutable zebraUSD;\n\taddress public immutable factory;\n\tuint256 public minNetDebt;\n\n\tmapping(ITroveManager => TroveManagerData) public troveManagersData;\n\tITroveManager[] internal _troveManagers;\n\n\tstruct TroveManagerData {\n\t\tIERC20 collateralToken;\n\t\tuint16 index;\n\t}\n\n\tstruct LocalVariables_adjustTrove {\n\t\tuint256 price;\n\t\tuint256 totalPricedCollateral;\n\t\tuint256 totalDebt;\n\t\tuint256 collChange;\n\t\tuint256 netDebtChange;\n\t\tbool isCollIncrease;\n\t\tuint256 debt;\n\t\tuint256 coll;\n\t\tuint256 newDebt;\n\t\tuint256 newColl;\n\t\tuint256 stake;\n\t\tuint256 debtChange;\n\t\taddress account;\n\t\tuint256 MCR;\n\t}\n\n\tstruct LocalVariables_openTrove {\n\t\tuint256 price;\n\t\tuint256 totalPricedCollateral;\n\t\tuint256 totalDebt;\n\t\tuint256 netDebt;\n\t\tuint256 compositeDebt;\n\t\tuint256 ICR;\n\t\tuint256 NICR;\n\t\tuint256 stake;\n\t\tuint256 arrayIndex;\n\t}\n\n\tconstructor(IZebraCore _zebraCore, address _zebraUSDAddress, address _factory, uint256 _minNetDebt, uint256 _gasCompensation) ZebraOwnable(_zebraCore) ZebraBase(_gasCompensation) {\n\t\tzebraUSD = IZebraUSD(_zebraUSDAddress);\n\t\tfactory = _factory;\n\t\t_setMinNetDebt(_minNetDebt);\n\t}\n\n\tfunction setMinNetDebt(uint256 _minNetDebt) public onlyOwner {\n\t\t_setMinNetDebt(_minNetDebt);\n\t}\n\n\tfunction _setMinNetDebt(uint256 _minNetDebt) internal {\n\t\trequire(_minNetDebt > 0, \"invalid min net debt\");\n\t\tminNetDebt = _minNetDebt;\n\t}\n\n\tfunction configureCollateral(ITroveManager troveManager, IERC20 collateralToken) external {\n\t\trequire(msg.sender == factory, \"!factory\");\n\t\ttroveManagersData[troveManager] = TroveManagerData(collateralToken, uint16(_troveManagers.length));\n\t\t_troveManagers.push(troveManager);\n\t\temit CollateralConfigured(troveManager, collateralToken);\n\t}\n\n\tfunction removeTroveManager(ITroveManager troveManager) external {\n\t\tTroveManagerData memory tmData = troveManagersData[troveManager];\n\t\trequire(address(tmData.collateralToken) != address(0) && troveManager.sunsetting() && troveManager.getEntireSystemDebt() == 0, \"Trove Manager cannot be removed\");\n\t\tdelete troveManagersData[troveManager];\n\t\tuint256 lastIndex = _troveManagers.length - 1;\n\t\tif (tmData.index < lastIndex) {\n\t\t\tITroveManager lastTm = _troveManagers[lastIndex];\n\t\t\t_troveManagers[tmData.index] = lastTm;\n\t\t\ttroveManagersData[lastTm].index = tmData.index;\n\t\t}\n\n\t\t_troveManagers.pop();\n\t\temit TroveManagerRemoved(troveManager);\n\t}\n\n\t/**\n        @notice Get the global total collateral ratio\n        @dev Not a view because fetching from the oracle is state changing.\n             Can still be accessed as a view from within the UX.\n     */\n\tfunction getTCR() external returns (uint256 globalTotalCollateralRatio) {\n\t\tSystemBalances memory balances = fetchBalances();\n\t\t(globalTotalCollateralRatio, , ) = _getTCRData(balances);\n\t\treturn globalTotalCollateralRatio;\n\t}\n\n\t/**\n        @notice Get total collateral and debt balances for all active collaterals, as well as\n                the current collateral prices\n        @dev Not a view because fetching from the oracle is state changing.\n             Can still be accessed as a view from within the UX.\n     */\n\tfunction fetchBalances() public returns (SystemBalances memory balances) {\n\t\tuint256 loopEnd = _troveManagers.length;\n\t\tbalances = SystemBalances({ collaterals: new uint256[](loopEnd), debts: new uint256[](loopEnd), prices: new uint256[](loopEnd) });\n\t\tfor (uint256 i; i < loopEnd; ) {\n\t\t\tITroveManager troveManager = _troveManagers[i];\n\t\t\t(uint256 collateral, uint256 debt, uint256 price) = troveManager.getEntireSystemBalances();\n\t\t\tbalances.collaterals[i] = collateral;\n\t\t\tbalances.debts[i] = debt;\n\t\t\tbalances.prices[i] = price;\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction checkRecoveryMode(uint256 TCR) public pure returns (bool) {\n\t\treturn TCR < CCR;\n\t}\n\n\tfunction getCompositeDebt(uint256 _debt) external view returns (uint256) {\n\t\treturn _getCompositeDebt(_debt);\n\t}\n\n\t// --- Borrower Trove Operations ---\n\tfunction openTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collateralAmount, uint256 _debtAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {\n\t\trequire(!ZebraCore.paused(), \"Deposits are paused\");\n\t\ttroveManager.distributeInterestDebt();\n\t\tIERC20 collateralToken;\n\t\tLocalVariables_openTrove memory vars;\n\t\tbool isRecoveryMode;\n\t\t(collateralToken, vars.price, vars.totalPricedCollateral, vars.totalDebt, isRecoveryMode) = _getCollateralAndTCRData(troveManager);\n\t\t_requireValidMaxFeePercentage(_maxFeePercentage);\n\n\t\tvars.netDebt = _debtAmount;\n\n\t\tif (!isRecoveryMode) {\n\t\t\tvars.netDebt = vars.netDebt + _triggerBorrowingFee(troveManager, account, _maxFeePercentage, _debtAmount);\n\t\t}\n\t\t_requireAtLeastMinNetDebt(vars.netDebt);\n\n\t\t// ICR is based on the composite debt, i.e. the requested Debt amount + Debt borrowing fee + Debt gas comp.\n\t\tvars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\t\tvars.ICR = ZebraMath._computeCR(_collateralAmount, vars.compositeDebt, vars.price);\n\t\tvars.NICR = ZebraMath._computeNominalCR(_collateralAmount, vars.compositeDebt);\n\n\t\tif (isRecoveryMode) {\n\t\t\t_requireICRisAboveCCR(vars.ICR);\n\t\t} else {\n\t\t\t_requireICRisAboveMCR(vars.ICR, troveManager.MCR());\n\t\t\tuint256 newTCR = _getNewTCRFromTroveChange(vars.totalPricedCollateral, vars.totalDebt, _collateralAmount * vars.price, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n\t\t\t_requireNewTCRisAboveCCR(newTCR);\n\t\t}\n\n\t\t// Create the trove\n\t\t(vars.stake, vars.arrayIndex) = troveManager.openTrove(account, _collateralAmount, vars.compositeDebt, vars.NICR, _upperHint, _lowerHint);\n\t\temit TroveCreated(account, vars.arrayIndex);\n\n\t\t// Move the collateral to the Trove Manager\n\t\tcollateralToken.safeTransferFrom(msg.sender, address(troveManager), _collateralAmount);\n\n\t\t//  and mint the DebtAmount to the caller and gas compensation for Gas Pool\n\t\tzebraUSD.mintWithGasCompensation(msg.sender, _debtAmount);\n\n\t\temit TroveUpdated(account, vars.compositeDebt, _collateralAmount, vars.stake, BorrowerOperation.openTrove);\n\t}\n\n\t// Send collateral to a trove\n\tfunction addColl(ITroveManager troveManager, address account, uint256 _collateralAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {\n\t\trequire(!ZebraCore.paused(), \"Trove adjustments are paused\");\n\t\t_adjustTrove(troveManager, account, 0, _collateralAmount, 0, 0, false, _upperHint, _lowerHint);\n\t}\n\n\t// Withdraw collateral from a trove\n\tfunction withdrawColl(ITroveManager troveManager, address account, uint256 _collWithdrawal, address _upperHint, address _lowerHint) external callerOrDelegated(account) {\n\t\t_adjustTrove(troveManager, account, 0, 0, _collWithdrawal, 0, false, _upperHint, _lowerHint);\n\t}\n\n\t// Withdraw Debt tokens from a trove: mint new Debt tokens to the owner, and increase the trove's debt accordingly\n\tfunction withdrawDebt(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _debtAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {\n\t\trequire(!ZebraCore.paused(), \"Withdrawals are paused\");\n\t\t_adjustTrove(troveManager, account, _maxFeePercentage, 0, 0, _debtAmount, true, _upperHint, _lowerHint);\n\t}\n\n\t// Repay Debt tokens to a Trove: Burn the repaid Debt tokens, and reduce the trove's debt accordingly\n\tfunction repayDebt(ITroveManager troveManager, address account, uint256 _debtAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {\n\t\t_adjustTrove(troveManager, account, 0, 0, 0, _debtAmount, false, _upperHint, _lowerHint);\n\t}\n\n\tfunction adjustTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collDeposit, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external callerOrDelegated(account) {\n\t\trequire((_collDeposit == 0 && !_isDebtIncrease) || !ZebraCore.paused(), \"Trove adjustments are paused\");\n\t\trequire(_collDeposit == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n\t\t_adjustTrove(troveManager, account, _maxFeePercentage, _collDeposit, _collWithdrawal, _debtChange, _isDebtIncrease, _upperHint, _lowerHint);\n\t}\n\n\tfunction _adjustTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collDeposit, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) internal {\n\t\trequire(_collDeposit != 0 || _collWithdrawal != 0 || _debtChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n\t\ttroveManager.distributeInterestDebt();\n\t\tIERC20 collateralToken;\n\t\tLocalVariables_adjustTrove memory vars;\n\t\tbool isRecoveryMode;\n\t\t(collateralToken, vars.price, vars.totalPricedCollateral, vars.totalDebt, isRecoveryMode) = _getCollateralAndTCRData(troveManager);\n\n\t\t(vars.coll, vars.debt) = troveManager.applyPendingRewards(account);\n\t\ttroveManager.repayInterest(msg.sender, account, vars.debt);\n\n\t\t// Get the collChange based on whether or not collateral was sent in the transaction\n\t\t(vars.collChange, vars.isCollIncrease) = _getCollChange(_collDeposit, _collWithdrawal);\n\t\tvars.netDebtChange = _debtChange;\n\t\tvars.debtChange = _debtChange;\n\t\tvars.account = account;\n\t\tvars.MCR = troveManager.MCR();\n\n\t\tif (_isDebtIncrease) {\n\t\t\trequire(_debtChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n\t\t\t_requireValidMaxFeePercentage(_maxFeePercentage);\n\t\t\tif (!isRecoveryMode) {\n\t\t\t\t// If the adjustment incorporates a debt increase and system is in Normal Mode, trigger a borrowing fee\n\t\t\t\tvars.netDebtChange += _triggerBorrowingFee(troveManager, msg.sender, _maxFeePercentage, _debtChange);\n\t\t\t}\n\t\t}\n\n\t\t// Calculate old and new ICRs and check if adjustment satisfies all conditions for the current system mode\n\t\t_requireValidAdjustmentInCurrentMode(vars.totalPricedCollateral, vars.totalDebt, isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n\n\t\t// When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Debt\n\t\tif (!_isDebtIncrease && _debtChange > 0) {\n\t\t\t_requireAtLeastMinNetDebt(_getNetDebt(vars.debt) - vars.netDebtChange);\n\t\t}\n\n\t\t// If we are incrasing collateral, send tokens to the trove manager prior to adjusting the trove\n\t\tif (vars.isCollIncrease) collateralToken.safeTransferFrom(msg.sender, address(troveManager), vars.collChange);\n\n\t\t(vars.newColl, vars.newDebt, vars.stake) = troveManager.updateTroveFromAdjustment(_isDebtIncrease, vars.debtChange, vars.netDebtChange, vars.isCollIncrease, vars.collChange, _upperHint, _lowerHint, vars.account, msg.sender);\n\n\t\temit TroveUpdated(vars.account, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n\t}\n\n\tfunction closeTrove(ITroveManager troveManager, address account) external callerOrDelegated(account) {\n\t\tIERC20 collateralToken;\n\n\t\tuint256 price;\n\t\tbool isRecoveryMode;\n\t\tuint256 totalPricedCollateral;\n\t\tuint256 totalDebt;\n\t\t(collateralToken, price, totalPricedCollateral, totalDebt, isRecoveryMode) = _getCollateralAndTCRData(troveManager);\n\t\trequire(!isRecoveryMode, \"BorrowerOps: Operation not permitted during Recovery Mode\");\n\t\ttroveManager.distributeInterestDebt();\n\t\t(uint256 coll, uint256 debt) = troveManager.applyPendingRewards(account);\n\t\ttroveManager.repayInterest(msg.sender, account, debt);\n\t\tuint256 newTCR = _getNewTCRFromTroveChange(totalPricedCollateral, totalDebt, coll * price, false, debt, false);\n\t\t_requireNewTCRisAboveCCR(newTCR);\n\n\t\ttroveManager.closeTrove(account, msg.sender, coll, debt);\n\n\t\temit TroveUpdated(account, 0, 0, 0, BorrowerOperation.closeTrove);\n\n\t\t// Burn the repaid Debt from the user's balance and the gas compensation from the Gas Pool\n\t\tzebraUSD.burnWithGasCompensation(msg.sender, debt - DEBT_GAS_COMPENSATION);\n\t}\n\n\t// --- Helper functions ---\n\n\tfunction _triggerBorrowingFee(ITroveManager _troveManager, address _caller, uint256 _maxFeePercentage, uint256 _debtAmount) internal returns (uint256) {\n\t\tuint256 debtFee = _troveManager.decayBaseRateAndGetBorrowingFee(_debtAmount);\n\n\t\t_requireUserAcceptsFee(debtFee, _debtAmount, _maxFeePercentage);\n\n\t\tzebraUSD.mint(ZebraCore.feeReceiver(), debtFee);\n\n\t\temit BorrowingFeePaid(_caller, debtFee);\n\n\t\treturn debtFee;\n\t}\n\n\tfunction _getCollChange(uint256 _collReceived, uint256 _requestedCollWithdrawal) internal pure returns (uint256 collChange, bool isCollIncrease) {\n\t\tif (_collReceived != 0) {\n\t\t\tcollChange = _collReceived;\n\t\t\tisCollIncrease = true;\n\t\t} else {\n\t\t\tcollChange = _requestedCollWithdrawal;\n\t\t}\n\t}\n\n\tfunction _requireValidAdjustmentInCurrentMode(uint256 totalPricedCollateral, uint256 totalDebt, bool _isRecoveryMode, uint256 _collWithdrawal, bool _isDebtIncrease, LocalVariables_adjustTrove memory _vars) internal pure {\n\t\t/*\n\t\t *In Recovery Mode, only allow:\n\t\t *\n\t\t * - Pure collateral top-up\n\t\t * - Pure debt repayment\n\t\t * - Collateral top-up with debt repayment\n\t\t * - A debt increase combined with a collateral top-up which makes the ICR >= 200% and improves the ICR (and by extension improves the TCR).\n\t\t *\n\t\t * In Normal Mode, ensure:\n\t\t *\n\t\t * - The new ICR is above MCR\n\t\t * - The adjustment won't pull the TCR below CCR\n\t\t */\n\n\t\t// Get the trove's old ICR before the adjustment\n\t\tuint256 oldICR = ZebraMath._computeCR(_vars.coll, _vars.debt, _vars.price);\n\n\t\t// Get the trove's new ICR after the adjustment\n\t\tuint256 newICR = _getNewICRFromTroveChange(_vars.coll, _vars.debt, _vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n\n\t\tif (_isRecoveryMode) {\n\t\t\trequire(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n\t\t\tif (_isDebtIncrease) {\n\t\t\t\t_requireICRisAboveCCR(newICR);\n\t\t\t\t_requireNewICRisAboveOldICR(newICR, oldICR);\n\t\t\t}\n\t\t} else {\n\t\t\t// if Normal Mode\n\t\t\t_requireICRisAboveMCR(newICR, _vars.MCR);\n\t\t\tuint256 newTCR = _getNewTCRFromTroveChange(totalPricedCollateral, totalDebt, _vars.collChange * _vars.price, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease);\n\t\t\t_requireNewTCRisAboveCCR(newTCR);\n\t\t}\n\t}\n\n\tfunction _requireICRisAboveMCR(uint256 _newICR, uint256 MCR) internal pure {\n\t\trequire(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n\t}\n\n\tfunction _requireICRisAboveCCR(uint256 _newICR) internal pure {\n\t\trequire(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n\t}\n\n\tfunction _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n\t\trequire(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n\t}\n\n\tfunction _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n\t\trequire(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n\t}\n\n\tfunction _requireAtLeastMinNetDebt(uint256 _netDebt) internal view {\n\t\trequire(_netDebt >= minNetDebt, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n\t}\n\n\tfunction _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n\t\trequire(_maxFeePercentage <= DECIMAL_PRECISION, \"Max fee percentage must less than or equal to 100%\");\n\t}\n\n\t// Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n\tfunction _getNewICRFromTroveChange(uint256 _coll, uint256 _debt, uint256 _collChange, bool _isCollIncrease, uint256 _debtChange, bool _isDebtIncrease, uint256 _price) internal pure returns (uint256) {\n\t\t(uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n\t\tuint256 newICR = ZebraMath._computeCR(newColl, newDebt, _price);\n\t\treturn newICR;\n\t}\n\n\tfunction _getNewTroveAmounts(uint256 _coll, uint256 _debt, uint256 _collChange, bool _isCollIncrease, uint256 _debtChange, bool _isDebtIncrease) internal pure returns (uint256, uint256) {\n\t\tuint256 newColl = _coll;\n\t\tuint256 newDebt = _debt;\n\t\tnewColl = _isCollIncrease ? _coll + _collChange : _coll - _collChange;\n\t\tnewDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n\n\t\treturn (newColl, newDebt);\n\t}\n\n\tfunction _getNewTCRFromTroveChange(uint256 totalColl, uint256 totalDebt, uint256 _collChange, bool _isCollIncrease, uint256 _debtChange, bool _isDebtIncrease) internal pure returns (uint256) {\n\t\ttotalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;\n\t\ttotalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;\n\n\t\tuint256 newTCR = ZebraMath._computeCR(totalColl, totalDebt);\n\t\treturn newTCR;\n\t}\n\n\tfunction _getTCRData(SystemBalances memory balances) internal pure returns (uint256 amount, uint256 totalPricedCollateral, uint256 totalDebt) {\n\t\tuint256 loopEnd = balances.collaterals.length;\n\t\tfor (uint256 i; i < loopEnd; ) {\n\t\t\ttotalPricedCollateral += (balances.collaterals[i] * balances.prices[i]);\n\t\t\ttotalDebt += balances.debts[i];\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\tamount = ZebraMath._computeCR(totalPricedCollateral, totalDebt);\n\n\t\treturn (amount, totalPricedCollateral, totalDebt);\n\t}\n\n\tfunction _getCollateralAndTCRData(ITroveManager troveManager) internal returns (IERC20 collateralToken, uint256 price, uint256 totalPricedCollateral, uint256 totalDebt, bool isRecoveryMode) {\n\t\tTroveManagerData storage t = troveManagersData[troveManager];\n\t\tuint256 index;\n\t\t(collateralToken, index) = (t.collateralToken, t.index);\n\n\t\trequire(address(collateralToken) != address(0), \"Collateral not enabled\");\n\n\t\tuint256 amount;\n\t\tSystemBalances memory balances = fetchBalances();\n\t\t(amount, totalPricedCollateral, totalDebt) = _getTCRData(balances);\n\t\tisRecoveryMode = checkRecoveryMode(amount);\n\n\t\treturn (collateralToken, balances.prices[index], totalPricedCollateral, totalDebt, isRecoveryMode);\n\t}\n\n\tfunction getGlobalSystemBalances() external returns (uint256 totalPricedCollateral, uint256 totalDebt) {\n\t\tSystemBalances memory balances = fetchBalances();\n\t\t(, totalPricedCollateral, totalDebt) = _getTCRData(balances);\n\t}\n}\n"
    },
    "contracts/core/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../dependencies/ZebraOwnable.sol\";\nimport \"../dependencies/console.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/IZebraUSD.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/ILiquidationManager.sol\";\n\n/**\n    @title Zebra Trove Factory\n    @notice Deploys cloned pairs of `TroveManager` and `SortedTroves` in order to\n            add new collateral types within the system.\n */\ncontract Factory is ZebraOwnable {\n\tusing Clones for address;\n\n\t// fixed single-deployment contracts\n\tIZebraUSD public immutable ZebraUSD;\n\tIStabilityPool public immutable stabilityPool;\n\tILiquidationManager public immutable liquidationManager;\n\tIBorrowerOperations public immutable borrowerOperations;\n\n\t// implementation contracts, redeployed each time via clone proxy\n\taddress public sortedTrovesImpl;\n\taddress public troveManagerImpl;\n\n\taddress[] public troveManagers;\n\n\t// commented values are suggested default parameters\n\tstruct DeploymentParams {\n\t\tuint256 minuteDecayFactor; // 999037758833783000  (half life of 12 hours)\n\t\tuint256 redemptionFeeFloor; // 1e18 / 1000 * 5  (0.5%)\n\t\tuint256 maxRedemptionFee; // 1e18  (100%)\n\t\tuint256 borrowingFeeFloor; // 1e18 / 1000 * 5  (0.5%)\n\t\tuint256 maxBorrowingFee; // 1e18 / 100 * 5  (5%)\n\t\tuint256 maxDebt;\n\t\tuint256 MCR; // 12 * 1e17  (120%)\n\t\tuint32 interestRate; // 1e4 (1%)\n\t}\n\n\tevent NewDeployment(IERC20 collateral, address priceFeed, address troveManager, address sortedTroves);\n\n\tconstructor(IZebraCore _ZebraCore, IZebraUSD _ZebraUSD, IStabilityPool _stabilityPool, IBorrowerOperations _borrowerOperations, address _sortedTroves, address _troveManager, ILiquidationManager _liquidationManager) ZebraOwnable(_ZebraCore) {\n\t\tZebraUSD = _ZebraUSD;\n\t\tstabilityPool = _stabilityPool;\n\t\tborrowerOperations = _borrowerOperations;\n\n\t\tsortedTrovesImpl = _sortedTroves;\n\t\ttroveManagerImpl = _troveManager;\n\t\tliquidationManager = _liquidationManager;\n\t}\n\n\tfunction troveManagerCount() external view returns (uint256) {\n\t\treturn troveManagers.length;\n\t}\n\n\t/**\n        @notice Deploy new instances of `TroveManager` and `SortedTroves`, adding\n                a new collateral type to the system.\n        @dev * When using the default `PriceFeed`, ensure it is configured correctly\n               prior to calling this function.\n             * After calling this function, the owner should also call `Vault.registerReceiver`\n               to enable Zebra emissions on the newly deployed `TroveManager`\n        @param collateral Collateral token to use in new deployment\n        @param priceFeed Custom `PriceFeed` deployment. Leave as `address(0)` to use the default.\n        @param customTroveManagerImpl Custom `TroveManager` implementation to clone from.\n                                      Leave as `address(0)` to use the default.\n        @param customSortedTrovesImpl Custom `SortedTroves` implementation to clone from.\n                                      Leave as `address(0)` to use the default.\n        @param params Struct of initial parameters to be set on the new trove manager\n     */\n\tfunction deployNewInstance(IERC20 collateral, address priceFeed, address customTroveManagerImpl, address customSortedTrovesImpl, DeploymentParams memory params) external onlyOwner {\n\t\taddress implementation = customTroveManagerImpl == address(0) ? troveManagerImpl : customTroveManagerImpl;\n\t\taddress troveManager = implementation.cloneDeterministic(bytes32(bytes20(address(collateral))));\n\t\ttroveManagers.push(troveManager);\n\t\timplementation = customSortedTrovesImpl == address(0) ? sortedTrovesImpl : customSortedTrovesImpl;\n\t\taddress sortedTroves = implementation.cloneDeterministic(bytes32(bytes20(troveManager)));\n\n\t\tITroveManager(troveManager).setAddresses(priceFeed, sortedTroves, collateral);\n\t\tISortedTroves(sortedTroves).setAddresses(troveManager);\n\n\t\t// verify that the oracle is correctly working\n\t\tITroveManager(troveManager).fetchPrice();\n\n\t\tstabilityPool.enableCollateral(collateral);\n\t\tliquidationManager.enableTroveManager(troveManager);\n\t\tZebraUSD.enableTroveManager(troveManager);\n\t\tborrowerOperations.configureCollateral(ITroveManager(troveManager), collateral);\n\n\t\tITroveManager(troveManager).setParameters(params.minuteDecayFactor, params.redemptionFeeFloor, params.maxRedemptionFee, params.borrowingFeeFloor, params.maxBorrowingFee, params.maxDebt, params.MCR, params.interestRate);\n\n\t\temit NewDeployment(collateral, priceFeed, troveManager, sortedTroves);\n\t}\n\n\tfunction setImplementations(address _troveManagerImpl, address _sortedTrovesImpl) external onlyOwner {\n\t\ttroveManagerImpl = _troveManagerImpl;\n\t\tsortedTrovesImpl = _sortedTrovesImpl;\n\t}\n}\n"
    },
    "contracts/core/InterestDebtPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IZebraUSD.sol\";\nimport \"../dependencies/ZebraMath.sol\";\nimport \"../dependencies/console.sol\";\n\nabstract contract InterestDebtPool {\n\tIZebraUSD public immutable ZebraUSD;\n\tuint64 internal constant PRECISION = 1e18;\n\tuint64 internal constant SECONDS_IN_YEAR = 365 days;\n\tuint32 internal constant MAXFP = 1e6;\n\tuint32 public interestRate;\n\tuint256 internal outstandingInterestDebt;\n\tuint256 public L_Interest_Debt;\n\tuint256 public lastInterestDebtUpdateTime;\n\tuint256 public lastInterestDebtError_Redistribution;\n\n\tconstructor(address _ZebraUSD) {\n\t\tZebraUSD = IZebraUSD(_ZebraUSD);\n\t}\n\n\tevent InterestDebtDistributed(uint256 debt);\n\n\tfunction getOutstandingInterestDebt() public view returns (uint256) {\n\t\treturn outstandingInterestDebt;\n\t}\n\n\tfunction getCurrentOutstandingInterestDebt() public view returns (uint256) {\n\t\treturn outstandingInterestDebt + getPendingSystemInterestDebt();\n\t}\n\n\tfunction decreaseOutstandingInterestDebt(uint256 amount) internal {\n\t\toutstandingInterestDebt -= amount;\n\t}\n\n\tfunction getEntireSystemDebt() public view virtual returns (uint256 entireSystemDebt);\n\n\tfunction _distributeInterestDebt() internal returns (uint256) {\n\t\tif (lastInterestDebtUpdateTime == 0) {\n\t\t\tlastInterestDebtUpdateTime = block.timestamp;\n\t\t\treturn 0;\n\t\t}\n\t\tif (lastInterestDebtUpdateTime == block.timestamp) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 systemDebt = getEntireSystemDebt();\n\t\tif (systemDebt == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 feeNumerator = (systemDebt * ((block.timestamp - lastInterestDebtUpdateTime) * interestRate * PRECISION)) / SECONDS_IN_YEAR / MAXFP + lastInterestDebtError_Redistribution;\n\t\tlastInterestDebtUpdateTime = block.timestamp;\n\t\tuint256 feeRewardPerUnitDebt = feeNumerator / systemDebt;\n\t\tlastInterestDebtError_Redistribution = feeNumerator - (feeRewardPerUnitDebt * systemDebt);\n\t\tL_Interest_Debt += feeRewardPerUnitDebt;\n\t\tuint256 interest = (feeRewardPerUnitDebt * systemDebt) / PRECISION;\n\t\toutstandingInterestDebt += interest;\n\t\tZebraUSD.mint(feeReceiver(), interest);\n\t\temit InterestDebtDistributed(interest);\n\t\treturn feeRewardPerUnitDebt;\n\t}\n\n\tfunction feeReceiver() public view virtual returns (address);\n\n\tfunction getPendingSystemInterestDebt() public view returns (uint256) {\n\t\tif (lastInterestDebtUpdateTime == 0 || lastInterestDebtUpdateTime == block.timestamp) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 systemDebt = getEntireSystemDebt();\n\t\tif (systemDebt == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 feeNumerator = (systemDebt * ((block.timestamp - lastInterestDebtUpdateTime) * interestRate * PRECISION)) / SECONDS_IN_YEAR / MAXFP + lastInterestDebtError_Redistribution;\n\t\tuint256 feeRewardPerUnitDebt = feeNumerator / systemDebt;\n\t\treturn (feeRewardPerUnitDebt * systemDebt) / PRECISION;\n\t}\n\n\tfunction getPendingInterestDebt() public view returns (uint256) {\n\t\tif (lastInterestDebtUpdateTime == 0 || lastInterestDebtUpdateTime == block.timestamp) {\n\t\t\treturn L_Interest_Debt;\n\t\t}\n\t\tuint256 systemDebt = getEntireSystemDebt();\n\t\tif (systemDebt == 0) {\n\t\t\treturn L_Interest_Debt;\n\t\t}\n\t\tuint256 feeNumerator = (systemDebt * (block.timestamp - lastInterestDebtUpdateTime) * interestRate * PRECISION) / SECONDS_IN_YEAR / MAXFP + lastInterestDebtError_Redistribution;\n\t\treturn L_Interest_Debt + feeNumerator / systemDebt;\n\t}\n}\n"
    },
    "contracts/core/LiquidationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../dependencies/ZebraMath.sol\";\nimport \"../dependencies/ZebraBase.sol\";\nimport \"../dependencies/console.sol\";\n\n/**\n    @title Zebra Liquidation Manager\n    @notice Based on Liquity's `TroveManager`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\n\n            This contract has a 1:n relationship with `TroveManager`, handling liquidations\n            for every active collateral within the system.\n\n            Anyone can call to liquidate an eligible trove at any time. There is no requirement\n            that liquidations happen in order according to trove ICRs. There are three ways that\n            a liquidation can occur:\n\n            1. ICR <= 100\n               The trove's entire debt and collateral is redistributed between remaining active troves.\n\n            2. 100 < ICR < MCR\n               The trove is liquidated using stability pool deposits. The collateral is distributed\n               amongst stability pool depositors. If the stability pool's balance is insufficient to\n               completely repay the trove, the remaining debt and collateral is redistributed between\n               the remaining active troves.\n\n            3. MCR <= ICR < TCR && TCR < CCR\n               The trove is liquidated using stability pool deposits. Collateral equal to MCR of\n               the value of the debt is distributed between stability pool depositors. The remaining\n               collateral is left claimable by the trove owner.\n */\ncontract LiquidationManager is ZebraBase {\n\tIStabilityPool public immutable stabilityPool;\n\tIBorrowerOperations public immutable borrowerOperations;\n\taddress public immutable factory;\n\n\tuint256 private constant _100pct = 1000000000000000000; // 1e18 == 100%\n\n\tmapping(ITroveManager => bool) internal _enabledTroveManagers;\n\n\t/*\n\t * --- Variable container structs for liquidations ---\n\t *\n\t * These structs are used to hold, return and assign variables inside the liquidation functions,\n\t * in order to avoid the error: \"CompilerError: Stack too deep\".\n\t **/\n\n\tstruct TroveManagerValues {\n\t\tuint256 price;\n\t\tuint256 MCR;\n\t\tbool sunsetting;\n\t}\n\n\tstruct LiquidationValues {\n\t\tuint256 entireTroveDebt;\n\t\tuint256 entireTroveColl;\n\t\tuint256 interest;\n\t\tuint256 collGasCompensation;\n\t\tuint256 debtGasCompensation;\n\t\tuint256 debtToOffset;\n\t\tuint256 collToSendToSP;\n\t\tuint256 debtToRedistribute;\n\t\tuint256 collToRedistribute;\n\t\tuint256 collSurplus;\n\t}\n\n\tstruct LiquidationTotals {\n\t\tuint256 totalCollInSequence;\n\t\tuint256 totalDebtInSequence;\n\t\tuint256 totalInterest;\n\t\tuint256 totalCollGasCompensation;\n\t\tuint256 totalDebtGasCompensation;\n\t\tuint256 totalDebtToOffset;\n\t\tuint256 totalCollToSendToSP;\n\t\tuint256 totalDebtToRedistribute;\n\t\tuint256 totalCollToRedistribute;\n\t\tuint256 totalCollSurplus;\n\t}\n\n\tevent TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, TroveManagerOperation _operation);\n\tevent TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _interest, TroveManagerOperation _operation);\n\tevent Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _collGasCompensation, uint256 _debtGasCompensation, uint256 _interest);\n\tevent TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\n\tevent TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, uint8 operation);\n\n\tenum TroveManagerOperation {\n\t\tapplyPendingRewards,\n\t\tliquidateInNormalMode,\n\t\tliquidateInRecoveryMode,\n\t\tredeemCollateral\n\t}\n\n\tconstructor(IStabilityPool _stabilityPoolAddress, IBorrowerOperations _borrowerOperations, address _factory, uint256 _gasCompensation) ZebraBase(_gasCompensation) {\n\t\tstabilityPool = _stabilityPoolAddress;\n\t\tborrowerOperations = _borrowerOperations;\n\t\tfactory = _factory;\n\t}\n\n\tfunction enableTroveManager(ITroveManager _troveManager) external {\n\t\trequire(msg.sender == factory, \"Not factory\");\n\t\t_enabledTroveManagers[_troveManager] = true;\n\t}\n\n\t// --- Trove Liquidation functions ---\n\n\t/**\n        @notice Liquidate a single trove\n        @dev Reverts if the trove is not active, or cannot be liquidated\n        @param borrower Borrower address to liquidate\n     */\n\tfunction liquidate(ITroveManager troveManager, address borrower) external {\n\t\trequire(troveManager.getTroveStatus(borrower) == 1, \"TroveManager: Trove does not exist or is closed\");\n\n\t\taddress[] memory borrowers = new address[](1);\n\t\tborrowers[0] = borrower;\n\t\tbatchLiquidateTroves(troveManager, borrowers);\n\t}\n\n\t/**\n        @notice Liquidate a sequence of troves\n        @dev Iterates through troves starting with the lowest ICR\n        @param maxTrovesToLiquidate The maximum number of troves to liquidate\n        @param maxICR Maximum ICR to liquidate. Should be set to MCR if the system\n                      is not in recovery mode, to minimize gas costs for this call.\n     */\n\tfunction liquidateTroves(ITroveManager troveManager, uint256 maxTrovesToLiquidate, uint256 maxICR) external {\n\t\trequire(_enabledTroveManagers[troveManager], \"TroveManager not approved\");\n\t\tIStabilityPool stabilityPoolCached = stabilityPool;\n\t\ttroveManager.distributeInterestDebt();\n\n\t\tISortedTroves sortedTrovesCached = ISortedTroves(troveManager.sortedTroves());\n\n\t\tLiquidationValues memory singleLiquidation;\n\t\tLiquidationTotals memory totals;\n\t\tTroveManagerValues memory troveManagerValues;\n\n\t\tuint256 trovesRemaining = maxTrovesToLiquidate;\n\t\tuint256 troveCount = troveManager.getTroveOwnersCount();\n\t\ttroveManagerValues.price = troveManager.fetchPrice();\n\t\ttroveManagerValues.sunsetting = troveManager.sunsetting();\n\t\ttroveManagerValues.MCR = troveManager.MCR();\n\t\tuint debtInStabPool = stabilityPoolCached.getTotalZebraUSDDeposits();\n\n\t\twhile (trovesRemaining > 0 && troveCount > 1) {\n\t\t\taddress account = sortedTrovesCached.getLast();\n\t\t\tuint ICR = troveManager.getCurrentICR(account, troveManagerValues.price);\n\t\t\tif (ICR > maxICR) {\n\t\t\t\t// set to 0 to ensure the next if block evaluates false\n\t\t\t\ttrovesRemaining = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ICR <= _100pct) {\n\t\t\t\tsingleLiquidation = _liquidateWithoutSP(troveManager, account);\n\t\t\t\t_applyLiquidationValuesToTotals(totals, singleLiquidation);\n\t\t\t} else if (ICR < troveManagerValues.MCR) {\n\t\t\t\tsingleLiquidation = _liquidateNormalMode(troveManager, account, debtInStabPool, troveManagerValues.sunsetting);\n\t\t\t\tdebtInStabPool -= singleLiquidation.debtToOffset;\n\t\t\t\t_applyLiquidationValuesToTotals(totals, singleLiquidation);\n\t\t\t} else break; // break if the loop reaches a Trove with ICR >= MCR\n\t\t\tunchecked {\n\t\t\t\t--trovesRemaining;\n\t\t\t\t--troveCount;\n\t\t\t}\n\t\t}\n\t\tif (trovesRemaining > 0 && !troveManagerValues.sunsetting && troveCount > 1) {\n\t\t\t(uint entireSystemColl, uint entireSystemDebt) = borrowerOperations.getGlobalSystemBalances();\n\t\t\tentireSystemColl -= totals.totalCollToSendToSP * troveManagerValues.price;\n\t\t\tentireSystemDebt -= totals.totalDebtToOffset;\n\t\t\taddress nextAccount = sortedTrovesCached.getLast();\n\t\t\tITroveManager _troveManager = troveManager; //stack too deep workaround\n\t\t\twhile (trovesRemaining > 0 && troveCount > 1) {\n\t\t\t\tuint ICR = troveManager.getCurrentICR(nextAccount, troveManagerValues.price);\n\t\t\t\tif (ICR > maxICR) break;\n\t\t\t\tunchecked {\n\t\t\t\t\t--trovesRemaining;\n\t\t\t\t}\n\t\t\t\taddress account = nextAccount;\n\t\t\t\tnextAccount = sortedTrovesCached.getPrev(account);\n\n\t\t\t\tuint256 TCR = ZebraMath._computeCR(entireSystemColl, entireSystemDebt);\n\t\t\t\tif (TCR >= CCR || ICR >= TCR) break;\n\t\t\t\tsingleLiquidation = _tryLiquidateWithCap(_troveManager, account, debtInStabPool, troveManagerValues.MCR, troveManagerValues.price);\n\t\t\t\tif (singleLiquidation.debtToOffset == 0) continue;\n\t\t\t\tdebtInStabPool -= singleLiquidation.debtToOffset;\n\t\t\t\tentireSystemColl -= (singleLiquidation.collToSendToSP + singleLiquidation.collSurplus) * troveManagerValues.price;\n\t\t\t\tentireSystemDebt -= singleLiquidation.debtToOffset;\n\t\t\t\t_applyLiquidationValuesToTotals(totals, singleLiquidation);\n\t\t\t\tunchecked {\n\t\t\t\t\t--troveCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trequire(totals.totalDebtInSequence > 0, \"nothing to liquidate\");\n\t\tif (totals.totalDebtToOffset > 0 || totals.totalCollToSendToSP > 0) {\n\t\t\t// Move liquidated collateral and Debt to the appropriate pools\n\t\t\tstabilityPoolCached.offset(troveManager.collateralToken(), totals.totalDebtToOffset, totals.totalCollToSendToSP);\n\t\t\ttroveManager.decreaseDebtAndSendCollateral(address(stabilityPoolCached), totals.totalDebtToOffset, totals.totalCollToSendToSP);\n\t\t}\n\t\ttroveManager.finalizeLiquidation(msg.sender, totals.totalDebtToRedistribute, totals.totalCollToRedistribute, totals.totalCollSurplus, totals.totalDebtGasCompensation, totals.totalCollGasCompensation, totals.totalInterest);\n\n\t\temit Liquidation(totals.totalDebtInSequence, totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus, totals.totalCollGasCompensation, totals.totalDebtGasCompensation, totals.totalInterest);\n\t}\n\n\t/**\n        @notice Liquidate a custom list of troves\n        @dev Reverts if there is not a single trove that can be liquidated\n        @param _troveArray List of borrower addresses to liquidate. Troves that were already\n                           liquidated, or cannot be liquidated, are ignored.\n     */\n\t/*\n\t * Attempt to liquidate a custom list of troves provided by the caller.\n\t */\n\tfunction batchLiquidateTroves(ITroveManager troveManager, address[] memory _troveArray) public {\n\t\trequire(_enabledTroveManagers[troveManager], \"TroveManager not approved\");\n\t\trequire(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\t\ttroveManager.distributeInterestDebt();\n\n\t\tLiquidationValues memory singleLiquidation;\n\t\tLiquidationTotals memory totals;\n\t\tTroveManagerValues memory troveManagerValues;\n\n\t\tIStabilityPool stabilityPoolCached = stabilityPool;\n\t\tuint debtInStabPool = stabilityPoolCached.getTotalZebraUSDDeposits();\n\t\ttroveManagerValues.price = troveManager.fetchPrice();\n\t\ttroveManagerValues.sunsetting = troveManager.sunsetting();\n\t\ttroveManagerValues.MCR = troveManager.MCR();\n\t\tuint troveCount = troveManager.getTroveOwnersCount();\n\t\tuint length = _troveArray.length;\n\t\tuint troveIter;\n\t\twhile (troveIter < length && troveCount > 1) {\n\t\t\t// first iteration round, when all liquidated troves have ICR < MCR we do not need to track TCR\n\t\t\taddress account = _troveArray[troveIter];\n\n\t\t\t// closed / non-existent troves return an ICR of type(uint).max and are ignored\n\t\t\tuint ICR = troveManager.getCurrentICR(account, troveManagerValues.price);\n\t\t\tif (ICR <= _100pct) {\n\t\t\t\tsingleLiquidation = _liquidateWithoutSP(troveManager, account);\n\t\t\t} else if (ICR < troveManagerValues.MCR) {\n\t\t\t\tsingleLiquidation = _liquidateNormalMode(troveManager, account, debtInStabPool, troveManagerValues.sunsetting);\n\t\t\t\tdebtInStabPool -= singleLiquidation.debtToOffset;\n\t\t\t} else {\n\t\t\t\t// As soon as we find a trove with ICR >= MCR we need to start tracking the global TCR with the next loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_applyLiquidationValuesToTotals(totals, singleLiquidation);\n\t\t\tunchecked {\n\t\t\t\t++troveIter;\n\t\t\t\t--troveCount;\n\t\t\t}\n\t\t}\n\n\t\tif (troveIter < length && troveCount > 1) {\n\t\t\t// second iteration round, if we receive a trove with ICR > MCR and need to track TCR\n\t\t\t(uint256 entireSystemColl, uint256 entireSystemDebt) = borrowerOperations.getGlobalSystemBalances();\n\t\t\tentireSystemColl -= totals.totalCollToSendToSP * troveManagerValues.price;\n\t\t\tentireSystemDebt -= totals.totalDebtToOffset;\n\t\t\twhile (troveIter < length && troveCount > 1) {\n\t\t\t\taddress account = _troveArray[troveIter];\n\t\t\t\tuint ICR = troveManager.getCurrentICR(account, troveManagerValues.price);\n\t\t\t\tunchecked {\n\t\t\t\t\t++troveIter;\n\t\t\t\t}\n\t\t\t\tif (ICR <= _100pct) {\n\t\t\t\t\tsingleLiquidation = _liquidateWithoutSP(troveManager, account);\n\t\t\t\t} else if (ICR < troveManagerValues.MCR) {\n\t\t\t\t\tsingleLiquidation = _liquidateNormalMode(troveManager, account, debtInStabPool, troveManagerValues.sunsetting);\n\t\t\t\t} else {\n\t\t\t\t\tuint256 TCR = ZebraMath._computeCR(entireSystemColl, entireSystemDebt);\n\t\t\t\t\tif (TCR >= CCR || ICR >= TCR || troveManagerValues.sunsetting) continue;\n\t\t\t\t\tsingleLiquidation = _tryLiquidateWithCap(troveManager, account, debtInStabPool, troveManagerValues.MCR, troveManagerValues.price);\n\t\t\t\t\tif (singleLiquidation.debtToOffset == 0) continue;\n\t\t\t\t}\n\n\t\t\t\tdebtInStabPool -= singleLiquidation.debtToOffset;\n\t\t\t\tentireSystemColl -= (singleLiquidation.collToSendToSP + singleLiquidation.collSurplus) * troveManagerValues.price;\n\t\t\t\tentireSystemDebt -= singleLiquidation.debtToOffset;\n\t\t\t\t_applyLiquidationValuesToTotals(totals, singleLiquidation);\n\t\t\t\tunchecked {\n\t\t\t\t\t--troveCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trequire(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\n\n\t\tif (totals.totalDebtToOffset > 0 || totals.totalCollToSendToSP > 0) {\n\t\t\t// Move liquidated collateral and Debt to the appropriate pools\n\t\t\tstabilityPoolCached.offset(troveManager.collateralToken(), totals.totalDebtToOffset, totals.totalCollToSendToSP);\n\t\t\ttroveManager.decreaseDebtAndSendCollateral(address(stabilityPoolCached), totals.totalDebtToOffset, totals.totalCollToSendToSP);\n\t\t}\n\t\ttroveManager.finalizeLiquidation(msg.sender, totals.totalDebtToRedistribute, totals.totalCollToRedistribute, totals.totalCollSurplus, totals.totalDebtGasCompensation, totals.totalCollGasCompensation, totals.totalInterest);\n\n\t\temit Liquidation(totals.totalDebtInSequence, totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus, totals.totalCollGasCompensation, totals.totalDebtGasCompensation, totals.totalInterest);\n\t}\n\n\t/**\n        @dev Perform a \"normal\" liquidation, where 100% < ICR < MCR. The trove\n             is liquidated as much as possible using the stability pool. Any\n             remaining debt and collateral are redistributed between active troves.\n     */\n\tfunction _liquidateNormalMode(ITroveManager troveManager, address _borrower, uint256 _debtInStabPool, bool sunsetting) internal returns (LiquidationValues memory singleLiquidation) {\n\t\tuint pendingDebtReward;\n\t\tuint pendingCollReward;\n\n\t\t(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, pendingDebtReward, pendingCollReward) = troveManager.getEntireDebtAndColl(_borrower);\n\t\tsingleLiquidation.interest = troveManager.getTroveInterest(_borrower, singleLiquidation.entireTroveDebt);\n\t\tsingleLiquidation.entireTroveDebt = singleLiquidation.entireTroveDebt + singleLiquidation.interest;\n\t\ttroveManager.movePendingTroveRewardsToActiveBalances(pendingDebtReward, pendingCollReward);\n\n\t\tsingleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n\t\tsingleLiquidation.debtGasCompensation = DEBT_GAS_COMPENSATION;\n\t\tuint256 collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n\t\t(singleLiquidation.debtToOffset, singleLiquidation.collToSendToSP, singleLiquidation.debtToRedistribute, singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _debtInStabPool, sunsetting);\n\n\t\ttroveManager.closeTroveByLiquidation(_borrower);\n\t\temit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, singleLiquidation.interest, TroveManagerOperation.liquidateInNormalMode);\n\t\temit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\n\t\treturn singleLiquidation;\n\t}\n\n\t/**\n        @dev Attempt to liquidate a single trove in recovery mode.\n             If MCR <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n             and there is Debt in the Stability Pool, only offset, with no redistribution,\n             but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             The remainder due to the capped rate will be claimable as collateral surplus.\n     */\n\tfunction _tryLiquidateWithCap(ITroveManager troveManager, address _borrower, uint256 _debtInStabPool, uint256 _MCR, uint256 _price) internal returns (LiquidationValues memory singleLiquidation) {\n\t\tuint entireTroveDebt;\n\t\tuint entireTroveColl;\n\t\tuint pendingDebtReward;\n\t\tuint pendingCollReward;\n\n\t\t(entireTroveDebt, entireTroveColl, pendingDebtReward, pendingCollReward) = troveManager.getEntireDebtAndColl(_borrower);\n\t\tuint256 interest = troveManager.getTroveInterest(_borrower, entireTroveDebt);\n\t\tentireTroveDebt = entireTroveDebt + interest;\n\t\tif (entireTroveDebt > _debtInStabPool) {\n\t\t\t// do not liquidate if the entire trove cannot be liquidated via SP\n\t\t\treturn singleLiquidation;\n\t\t}\n\n\t\ttroveManager.movePendingTroveRewardsToActiveBalances(pendingDebtReward, pendingCollReward);\n\n\t\tsingleLiquidation.entireTroveDebt = entireTroveDebt + interest;\n\t\tsingleLiquidation.interest = interest;\n\t\tsingleLiquidation.entireTroveColl = entireTroveColl;\n\t\tuint256 collToOffset = (singleLiquidation.entireTroveDebt * _MCR) / _price;\n\n\t\tsingleLiquidation.collGasCompensation = _getCollGasCompensation(collToOffset);\n\t\tsingleLiquidation.debtGasCompensation = DEBT_GAS_COMPENSATION;\n\n\t\tsingleLiquidation.debtToOffset = singleLiquidation.entireTroveDebt;\n\t\tsingleLiquidation.collToSendToSP = collToOffset - singleLiquidation.collGasCompensation;\n\n\t\ttroveManager.closeTroveByLiquidation(_borrower);\n\n\t\tuint256 collSurplus = entireTroveColl - collToOffset;\n\t\tif (collSurplus > 0) {\n\t\t\tsingleLiquidation.collSurplus = collSurplus;\n\t\t\ttroveManager.addCollateralSurplus(_borrower, collSurplus);\n\t\t}\n\n\t\temit TroveLiquidated(_borrower, entireTroveDebt, singleLiquidation.collToSendToSP, interest, TroveManagerOperation.liquidateInRecoveryMode);\n\t\temit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n\n\t\treturn singleLiquidation;\n\t}\n\n\t/**\n        @dev Liquidate a trove without using the stability pool. All debt and collateral\n             are distributed porportionally between the remaining active troves.\n     */\n\tfunction _liquidateWithoutSP(ITroveManager troveManager, address _borrower) internal returns (LiquidationValues memory singleLiquidation) {\n\t\tuint pendingDebtReward;\n\t\tuint pendingCollReward;\n\n\t\t(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, pendingDebtReward, pendingCollReward) = troveManager.getEntireDebtAndColl(_borrower);\n\t\tsingleLiquidation.interest = troveManager.getTroveInterest(_borrower, singleLiquidation.entireTroveDebt);\n\t\tsingleLiquidation.entireTroveDebt = singleLiquidation.entireTroveDebt + singleLiquidation.interest;\n\t\tsingleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\n\t\tsingleLiquidation.debtGasCompensation = DEBT_GAS_COMPENSATION;\n\t\ttroveManager.movePendingTroveRewardsToActiveBalances(pendingDebtReward, pendingCollReward);\n\n\t\tsingleLiquidation.debtToOffset = 0;\n\t\tsingleLiquidation.collToSendToSP = 0;\n\t\tsingleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n\t\tsingleLiquidation.collToRedistribute = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\n\n\t\ttroveManager.closeTroveByLiquidation(_borrower);\n\t\temit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, singleLiquidation.interest, TroveManagerOperation.liquidateInRecoveryMode);\n\t\temit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\n\t\treturn singleLiquidation;\n\t}\n\n\t/* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n\t * redistributed to active troves.\n\t */\n\tfunction _getOffsetAndRedistributionVals(uint256 _debt, uint256 _coll, uint256 _debtInStabPool, bool sunsetting) internal pure returns (uint256 debtToOffset, uint256 collToSendToSP, uint256 debtToRedistribute, uint256 collToRedistribute) {\n\t\tif (_debtInStabPool > 0 && !sunsetting) {\n\t\t\t/*\n\t\t\t * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n\t\t\t * between all active troves.\n\t\t\t *\n\t\t\t *  If the trove's debt is larger than the deposited Debt in the Stability Pool:\n\t\t\t *\n\t\t\t *  - Offset an amount of the trove's debt equal to the Debt in the Stability Pool\n\t\t\t *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n\t\t\t *\n\t\t\t */\n\t\t\tdebtToOffset = ZebraMath._min(_debt, _debtInStabPool);\n\t\t\tcollToSendToSP = (_coll * debtToOffset) / _debt;\n\t\t\tdebtToRedistribute = _debt - debtToOffset;\n\t\t\tcollToRedistribute = _coll - collToSendToSP;\n\t\t} else {\n\t\t\tdebtToOffset = 0;\n\t\t\tcollToSendToSP = 0;\n\t\t\tdebtToRedistribute = _debt;\n\t\t\tcollToRedistribute = _coll;\n\t\t}\n\t}\n\n\t/**\n        @dev Adds values from `singleLiquidation` to `totals`\n             Calling this function mutates `totals`, the change is done in-place\n             to avoid needless expansion of memory\n     */\n\tfunction _applyLiquidationValuesToTotals(LiquidationTotals memory totals, LiquidationValues memory singleLiquidation) internal pure {\n\t\t// Tally all the values with their respective running totals\n\t\ttotals.totalCollGasCompensation = totals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\n\t\ttotals.totalDebtGasCompensation = totals.totalDebtGasCompensation + singleLiquidation.debtGasCompensation;\n\t\ttotals.totalDebtInSequence = totals.totalDebtInSequence + singleLiquidation.entireTroveDebt;\n\t\ttotals.totalInterest = totals.totalInterest + singleLiquidation.interest;\n\t\ttotals.totalCollInSequence = totals.totalCollInSequence + singleLiquidation.entireTroveColl;\n\t\ttotals.totalDebtToOffset = totals.totalDebtToOffset + singleLiquidation.debtToOffset;\n\t\ttotals.totalCollToSendToSP = totals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\n\t\ttotals.totalDebtToRedistribute = totals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\n\t\ttotals.totalCollToRedistribute = totals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\n\t\ttotals.totalCollSurplus = totals.totalCollSurplus + singleLiquidation.collSurplus;\n\t}\n}\n"
    },
    "contracts/core/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ITroveManager.sol\";\n\n/**\n    @title Zebra Sorted Troves\n    @notice Based on Liquity's `SortedTroves`:\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/SortedTroves.sol\n\n            Originally derived from `SortedDoublyLinkedList`:\n            https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n */\ncontract SortedTroves {\n\tITroveManager public troveManager;\n\n\tData public data;\n\n\t// Information for a node in the list\n\tstruct Node {\n\t\tbool exists;\n\t\taddress nextId; // Id of next node (smaller NICR) in the list\n\t\taddress prevId; // Id of previous node (larger NICR) in the list\n\t}\n\n\t// Information for the list\n\tstruct Data {\n\t\taddress head; // Head of the list. Also the node in the list with the largest NICR\n\t\taddress tail; // Tail of the list. Also the node in the list with the smallest NICR\n\t\tuint256 size; // Current size of the list\n\t\tmapping(address => Node) nodes; // Track the corresponding ids for each node in the list\n\t}\n\n\tevent NodeAdded(address _id, uint256 _NICR);\n\tevent NodeRemoved(address _id);\n\n\tfunction setAddresses(address _troveManagerAddress) external {\n\t\trequire(address(troveManager) == address(0), \"Already set\");\n\t\ttroveManager = ITroveManager(_troveManagerAddress);\n\t}\n\n\t/*\n\t * @dev Add a node to the list\n\t * @param _id Node's id\n\t * @param _NICR Node's NICR\n\t * @param _prevId Id of previous node for the insert position\n\t * @param _nextId Id of next node for the insert position\n\t */\n\n\tfunction insert(address _id, uint256 _NICR, address _prevId, address _nextId) external {\n\t\tITroveManager troveManagerCached = troveManager;\n\n\t\t_requireCallerIsTroveManager(troveManagerCached);\n\n\t\tNode storage node = data.nodes[_id];\n\t\t// List must not already contain node\n\t\trequire(!node.exists, \"SortedTroves: List already contains the node\");\n\t\t// Node id must not be null\n\t\trequire(_id != address(0), \"SortedTroves: Id cannot be zero\");\n\n\t\t_insert(node, troveManagerCached, _id, _NICR, _prevId, _nextId);\n\t}\n\n\tfunction _insert(Node storage node, ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\n\t\t// NICR must be non-zero\n\t\trequire(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n\t\taddress prevId = _prevId;\n\t\taddress nextId = _nextId;\n\n\t\tif (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n\t\t\t// Sender's hint was not a valid insert position\n\t\t\t// Use sender's hint to find a valid insert position\n\t\t\t(prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\n\t\t}\n\n\t\tnode.exists = true;\n\n\t\tif (prevId == address(0) && nextId == address(0)) {\n\t\t\t// Insert as head and tail\n\t\t\tdata.head = _id;\n\t\t\tdata.tail = _id;\n\t\t} else if (prevId == address(0)) {\n\t\t\t// Insert before `prevId` as the head\n\t\t\taddress head = data.head;\n\t\t\tnode.nextId = head;\n\t\t\tdata.nodes[head].prevId = _id;\n\t\t\tdata.head = _id;\n\t\t} else if (nextId == address(0)) {\n\t\t\t// Insert after `nextId` as the tail\n\t\t\taddress tail = data.tail;\n\t\t\tnode.prevId = tail;\n\t\t\tdata.nodes[tail].nextId = _id;\n\t\t\tdata.tail = _id;\n\t\t} else {\n\t\t\t// Insert at insert position between `prevId` and `nextId`\n\t\t\tnode.nextId = nextId;\n\t\t\tnode.prevId = prevId;\n\t\t\tdata.nodes[prevId].nextId = _id;\n\t\t\tdata.nodes[nextId].prevId = _id;\n\t\t}\n\n\t\tdata.size = data.size + 1;\n\t\temit NodeAdded(_id, _NICR);\n\t}\n\n\tfunction remove(address _id) external {\n\t\t_requireCallerIsTroveManager(troveManager);\n\t\t_remove(data.nodes[_id], _id);\n\t}\n\n\t/*\n\t * @dev Remove a node from the list\n\t * @param _id Node's id\n\t */\n\tfunction _remove(Node storage node, address _id) internal {\n\t\t// List must contain the node\n\t\trequire(node.exists, \"SortedTroves: List does not contain the id\");\n\n\t\tif (data.size > 1) {\n\t\t\t// List contains more than a single node\n\t\t\tif (_id == data.head) {\n\t\t\t\t// The removed node is the head\n\t\t\t\t// Set head to next node\n\t\t\t\taddress head = node.nextId;\n\t\t\t\tdata.head = head;\n\t\t\t\t// Set prev pointer of new head to null\n\t\t\t\tdata.nodes[head].prevId = address(0);\n\t\t\t} else if (_id == data.tail) {\n\t\t\t\taddress tail = node.prevId;\n\t\t\t\t// The removed node is the tail\n\t\t\t\t// Set tail to previous node\n\t\t\t\tdata.tail = tail;\n\t\t\t\t// Set next pointer of new tail to null\n\t\t\t\tdata.nodes[tail].nextId = address(0);\n\t\t\t} else {\n\t\t\t\taddress prevId = node.prevId;\n\t\t\t\taddress nextId = node.nextId;\n\t\t\t\t// The removed node is neither the head nor the tail\n\t\t\t\t// Set next pointer of previous node to the next node\n\t\t\t\tdata.nodes[prevId].nextId = nextId;\n\t\t\t\t// Set prev pointer of next node to the previous node\n\t\t\t\tdata.nodes[nextId].prevId = prevId;\n\t\t\t}\n\t\t} else {\n\t\t\t// List contains a single node\n\t\t\t// Set the head and tail to null\n\t\t\tdata.head = address(0);\n\t\t\tdata.tail = address(0);\n\t\t}\n\n\t\tdelete data.nodes[_id];\n\t\tdata.size = data.size - 1;\n\t\temit NodeRemoved(_id);\n\t}\n\n\t/*\n\t * @dev Re-insert the node at a new position, based on its new NICR\n\t * @param _id Node's id\n\t * @param _newNICR Node's new NICR\n\t * @param _prevId Id of previous node for the new insert position\n\t * @param _nextId Id of next node for the new insert position\n\t */\n\tfunction reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external {\n\t\tITroveManager troveManagerCached = troveManager;\n\n\t\t_requireCallerIsTroveManager(troveManagerCached);\n\n\t\tNode storage node = data.nodes[_id];\n\n\t\t// Remove node from the list\n\t\t_remove(node, _id);\n\n\t\t_insert(node, troveManagerCached, _id, _newNICR, _prevId, _nextId);\n\t}\n\n\t/*\n\t * @dev Checks if the list contains a node\n\t */\n\tfunction contains(address _id) public view returns (bool) {\n\t\treturn data.nodes[_id].exists;\n\t}\n\n\t/*\n\t * @dev Checks if the list is empty\n\t */\n\tfunction isEmpty() public view returns (bool) {\n\t\treturn data.size == 0;\n\t}\n\n\t/*\n\t * @dev Returns the current size of the list\n\t */\n\tfunction getSize() external view returns (uint256) {\n\t\treturn data.size;\n\t}\n\n\t/*\n\t * @dev Returns the first node in the list (node with the largest NICR)\n\t */\n\tfunction getFirst() external view returns (address) {\n\t\treturn data.head;\n\t}\n\n\t/*\n\t * @dev Returns the last node in the list (node with the smallest NICR)\n\t */\n\tfunction getLast() external view returns (address) {\n\t\treturn data.tail;\n\t}\n\n\t/*\n\t * @dev Returns the next node (with a smaller NICR) in the list for a given node\n\t * @param _id Node's id\n\t */\n\tfunction getNext(address _id) external view returns (address) {\n\t\treturn data.nodes[_id].nextId;\n\t}\n\n\t/*\n\t * @dev Returns the previous node (with a larger NICR) in the list for a given node\n\t * @param _id Node's id\n\t */\n\tfunction getPrev(address _id) external view returns (address) {\n\t\treturn data.nodes[_id].prevId;\n\t}\n\n\t/*\n\t * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n\t * @param _NICR Node's NICR\n\t * @param _prevId Id of previous node for the insert position\n\t * @param _nextId Id of next node for the insert position\n\t */\n\tfunction validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (bool) {\n\t\treturn _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n\t}\n\n\tfunction _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\n\t\tif (_prevId == address(0) && _nextId == address(0)) {\n\t\t\t// `(null, null)` is a valid insert position if the list is empty\n\t\t\treturn isEmpty();\n\t\t} else if (_prevId == address(0)) {\n\t\t\t// `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n\t\t\treturn data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\n\t\t} else if (_nextId == address(0)) {\n\t\t\t// `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n\t\t\treturn data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\n\t\t} else {\n\t\t\t// `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n\t\t\treturn data.nodes[_prevId].nextId == _nextId && _troveManager.getNominalICR(_prevId) >= _NICR && _NICR >= _troveManager.getNominalICR(_nextId);\n\t\t}\n\t}\n\n\t/*\n\t * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n\t * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n\t * @param _NICR Node's NICR\n\t * @param _startId Id of node to start descending the list from\n\t */\n\tfunction _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\n\t\t// If `_startId` is the head, check if the insert position is before the head\n\t\tif (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\n\t\t\treturn (address(0), _startId);\n\t\t}\n\n\t\taddress prevId = _startId;\n\t\taddress nextId = data.nodes[prevId].nextId;\n\n\t\t// Descend the list until we reach the end or until we find a valid insert position\n\t\twhile (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n\t\t\tprevId = data.nodes[prevId].nextId;\n\t\t\tnextId = data.nodes[prevId].nextId;\n\t\t}\n\n\t\treturn (prevId, nextId);\n\t}\n\n\t/*\n\t * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n\t * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n\t * @param _NICR Node's NICR\n\t * @param _startId Id of node to start ascending the list from\n\t */\n\tfunction _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\n\t\t// If `_startId` is the tail, check if the insert position is after the tail\n\t\tif (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\n\t\t\treturn (_startId, address(0));\n\t\t}\n\n\t\taddress nextId = _startId;\n\t\taddress prevId = data.nodes[nextId].prevId;\n\n\t\t// Ascend the list until we reach the end or until we find a valid insertion point\n\t\twhile (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n\t\t\tnextId = data.nodes[nextId].prevId;\n\t\t\tprevId = data.nodes[nextId].prevId;\n\t\t}\n\n\t\treturn (prevId, nextId);\n\t}\n\n\t/*\n\t * @dev Find the insert position for a new node with the given NICR\n\t * @param _NICR Node's NICR\n\t * @param _prevId Id of previous node for the insert position\n\t * @param _nextId Id of next node for the insert position\n\t */\n\tfunction findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (address, address) {\n\t\treturn _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n\t}\n\n\tfunction _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\n\t\taddress prevId = _prevId;\n\t\taddress nextId = _nextId;\n\n\t\tif (prevId != address(0)) {\n\t\t\tif (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\n\t\t\t\t// `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n\t\t\t\tprevId = address(0);\n\t\t\t}\n\t\t}\n\n\t\tif (nextId != address(0)) {\n\t\t\tif (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\n\t\t\t\t// `nextId` does not exist anymore or now has a larger NICR than the given NICR\n\t\t\t\tnextId = address(0);\n\t\t\t}\n\t\t}\n\n\t\tif (prevId == address(0) && nextId == address(0)) {\n\t\t\t// No hint - descend list starting from head\n\t\t\treturn _descendList(_troveManager, _NICR, data.head);\n\t\t} else if (prevId == address(0)) {\n\t\t\t// No `prevId` for hint - ascend list starting from `nextId`\n\t\t\treturn _ascendList(_troveManager, _NICR, nextId);\n\t\t} else if (nextId == address(0)) {\n\t\t\t// No `nextId` for hint - descend list starting from `prevId`\n\t\t\treturn _descendList(_troveManager, _NICR, prevId);\n\t\t} else {\n\t\t\t// Descend list starting from `prevId`\n\t\t\treturn _descendList(_troveManager, _NICR, prevId);\n\t\t}\n\t}\n\n\tfunction _requireCallerIsTroveManager(ITroveManager _troveManager) internal view {\n\t\trequire(msg.sender == address(_troveManager), \"SortedTroves: Caller is not the TroveManager\");\n\t}\n}\n"
    },
    "contracts/core/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/IZebraUSD.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../dependencies/ZebraBase.sol\";\nimport \"../dependencies/ZebraOwnable.sol\";\nimport \"../dependencies/SystemStart.sol\";\nimport \"../dependencies/ZebraMath.sol\";\nimport \"./InterestDebtPool.sol\";\n\n/**\n    @title Zebra Trove Manager\n    @notice Based on Liquity's `TroveManager`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/TroveManager.sol\n\n            Zebra's implementation is modified so that multiple `TroveManager` and `SortedTroves`\n            contracts are deployed in tandem, with each pair managing troves of a single collateral\n            type.\n\n            Functionality related to liquidations has been moved to `LiquidationManager`. This was\n            necessary to avoid the restriction on deployed bytecode size.\n */\ncontract TroveManager is ITroveManager, InterestDebtPool, ZebraBase, ZebraOwnable, SystemStart {\n\tusing SafeERC20 for IERC20;\n\n\t// --- Connected contract declarations ---\n\taddress public immutable borrowerOperationsAddress;\n\taddress public immutable liquidationManager;\n\taddress public immutable gasPoolAddress;\n\n\tIPriceFeed public override priceFeed;\n\tIERC20 public collateralToken;\n\n\t// A doubly linked list of Troves, sorted by their collateral ratios\n\tISortedTroves public override sortedTroves;\n\n\t// Minimum collateral ratio for individual troves\n\tuint256 public MCR;\n\n\tuint256 internal constant SECONDS_IN_ONE_MINUTE = 60;\n\n\t// During bootsrap period redemptions are not allowed\n\tuint256 public constant BOOTSTRAP_PERIOD = 14 days;\n\tuint32 public constant SUNSETTING_INTEREST_RATE = 5e5; //50%\n\n\t/*\n\t * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n\t * Corresponds to (1 / ALPHA) in the white paper.\n\t */\n\tuint256 internal constant BETA = 2;\n\n\t// commented values are Liquity's fixed settings for each parameter\n\tuint256 public minuteDecayFactor; // 999037758833783000  (half-life of 12 hours)\n\tuint256 public redemptionFeeFloor; // DECIMAL_PRECISION / 1000 * 5  (0.5%)\n\tuint256 public maxRedemptionFee; // DECIMAL_PRECISION  (100%)\n\tuint256 public borrowingFeeFloor; // DECIMAL_PRECISION / 1000 * 5  (0.5%)\n\tuint256 public maxBorrowingFee; // DECIMAL_PRECISION / 100 * 5  (5%)\n\tuint256 public maxSystemDebt;\n\n\tuint256 public systemDeploymentTime;\n\tbool public paused;\n\tbool public sunsetting;\n\n\tuint256 public baseRate;\n\n\t// The timestamp of the latest fee operation (redemption or new debt issuance)\n\tuint256 public lastFeeOperationTime;\n\n\tuint256 public totalStakes;\n\n\t// Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n\tuint256 public totalStakesSnapshot;\n\n\t// Snapshot of the total collateral taken immediately after the latest liquidation.\n\tuint256 public totalCollateralSnapshot;\n\n\t/*\n\t * L_collateral and L_debt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n\t *\n\t * An collateral gain of ( stake * [L_collateral - L_collateral(0)] )\n\t * A debt increase  of ( stake * [L_debt - L_debt(0)] )\n\t *\n\t * Where L_collateral(0) and L_debt(0) are snapshots of L_collateral and L_debt for the active Trove taken at the instant the stake was made\n\t */\n\tuint256 public L_collateral;\n\tuint256 public L_debt;\n\n\t// Error trackers for the trove redistribution calculation\n\tuint256 public lastCollateralError_Redistribution;\n\tuint256 public lastDebtError_Redistribution;\n\n\tuint256 internal totalActiveCollateral;\n\tuint256 internal totalActiveDebt;\n\tuint256 public interestPayable;\n\n\tuint256 public defaultedCollateral;\n\tuint256 public defaultedDebt;\n\n\tuint256 public rewardIntegral;\n\tuint128 public rewardRate;\n\tuint32 public periodFinish;\n\n\tmapping(address => Trove) internal Troves;\n\n\tmapping(address => RewardSnapshot) internal rewardSnapshots;\n\n\tmapping(address => uint256) public surplusBalances;\n\n\t// Map addresses with active troves to their RewardSnapshot\n\n\t// Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n\taddress[] public TroveOwners;\n\n\tmodifier whenNotPaused() {\n\t\trequire(!paused, \"Collateral Paused\");\n\t\t_;\n\t}\n\n\tconstructor(\n\t\tIZebraCore _zebraCore,\n\t\taddress _gasPoolAddress,\n\t\taddress _zebraUSDAddress,\n\t\taddress _borrowerOperationsAddress,\n\t\taddress _liquidationManager,\n\t\tuint256 _gasCompensation\n\t) InterestDebtPool(_zebraUSDAddress) ZebraOwnable(_zebraCore) ZebraBase(_gasCompensation) SystemStart(_zebraCore) {\n\t\tgasPoolAddress = _gasPoolAddress;\n\t\tborrowerOperationsAddress = _borrowerOperationsAddress;\n\t\tliquidationManager = _liquidationManager;\n\t}\n\n\tfunction setAddresses(address _priceFeedAddress, address _sortedTrovesAddress, IERC20 _collateralToken) external override {\n\t\tassert(address(sortedTroves) == address(0));\n\t\tpriceFeed = IPriceFeed(_priceFeedAddress);\n\t\tsortedTroves = ISortedTroves(_sortedTrovesAddress);\n\t\tcollateralToken = IERC20(_collateralToken);\n\t\tsunsetting = false;\n\n\t\tsystemDeploymentTime = block.timestamp;\n\t}\n\n\tfunction feeReceiver() public view override returns (address) {\n\t\treturn ZebraCore.feeReceiver();\n\t}\n\n\tfunction startSunset() external onlyOwner {\n\t\t_distributeInterestDebt();\n\t\tsunsetting = true;\n\t\tinterestRate = SUNSETTING_INTEREST_RATE;\n\t\tredemptionFeeFloor = 0;\n\t\tmaxSystemDebt = 0;\n\t}\n\n\t/**\n\t * @notice Sets the pause state for this trove manager\n\t *         Pausing is used to mitigate risks in exceptional circumstances\n\t *         Functionalities affected by pausing are:\n\t *         - New borrowing is not possible\n\t *         - New collateral deposits are not possible\n\t * @param _paused If true the protocol is paused\n\t */\n\tfunction setPaused(bool _paused) external {\n\t\trequire((_paused && msg.sender == guardian()) || msg.sender == owner(), \"Unauthorized\");\n\t\tpaused = _paused;\n\t}\n\n\t/**\n\t * @notice Sets a custom price feed for this trove manager\n\t * @param _priceFeedAddress Price feed address\n\t */\n\tfunction setPriceFeed(address _priceFeedAddress) external onlyOwner {\n\t\tpriceFeed = IPriceFeed(_priceFeedAddress);\n\t}\n\n\tfunction setInterestRate(uint32 _interestRate) external onlyOwner {\n\t\tassert(_interestRate <= MAXFP / 10);\n\t\t_distributeInterestDebt();\n\t\tinterestRate = _interestRate;\n\t}\n\n\tfunction setMCR(uint256 _MCR) external onlyOwner {\n\t\trequire(_MCR <= CCR && _MCR >= 1100000000000000000, \"MCR cannot be > CCR or < 110%\");\n\t\tMCR = _MCR;\n\t}\n\n\tfunction setMaxSystemDebt(uint256 _maxSystemDebt) external onlyOwner {\n\t\trequire(_maxSystemDebt > getEntireSystemDebt(), \"new max system debt must be greater than current system debt\");\n\t\tmaxSystemDebt = _maxSystemDebt;\n\t}\n\n\t/*\n        _minuteDecayFactor is calculated as\n\n            10**18 * (1/2)**(1/n)\n\n        where n = the half-life in minutes\n     */\n\tfunction setParameters(uint256 _minuteDecayFactor, uint256 _redemptionFeeFloor, uint256 _maxRedemptionFee, uint256 _borrowingFeeFloor, uint256 _maxBorrowingFee, uint256 _maxSystemDebt, uint256 _MCR, uint32 _interestRate) public {\n\t\trequire(!sunsetting, \"Cannot change after sunset\");\n\t\trequire(_MCR <= CCR && _MCR >= 1100000000000000000, \"MCR cannot be > CCR or < 110%\");\n\t\tif (minuteDecayFactor != 0) {\n\t\t\trequire(msg.sender == owner(), \"Only owner\");\n\t\t}\n\t\tassert(\n\t\t\t_minuteDecayFactor >= 977159968434245000 && // half-life of 30 minutes\n\t\t\t\t_minuteDecayFactor <= 999931237762985000 // half-life of 1 week\n\t\t);\n\t\tassert(_redemptionFeeFloor <= _maxRedemptionFee && _maxRedemptionFee <= DECIMAL_PRECISION);\n\t\tassert(_borrowingFeeFloor <= _maxBorrowingFee && _maxBorrowingFee <= DECIMAL_PRECISION);\n\t\tassert(_interestRate <= MAXFP / 10);\n\t\t_distributeInterestDebt();\n\t\t_decayBaseRate();\n\n\t\tminuteDecayFactor = _minuteDecayFactor;\n\t\tredemptionFeeFloor = _redemptionFeeFloor;\n\t\tmaxRedemptionFee = _maxRedemptionFee;\n\t\tborrowingFeeFloor = _borrowingFeeFloor;\n\t\tmaxBorrowingFee = _maxBorrowingFee;\n\t\tmaxSystemDebt = _maxSystemDebt;\n\n\t\tMCR = _MCR;\n\t\tinterestRate = _interestRate;\n\t}\n\n\tfunction distributeInterestDebt() public returns (uint256) {\n\t\treturn _distributeInterestDebt();\n\t}\n\n\t// --- Getters ---\n\n\tfunction fetchPrice() public returns (uint256) {\n\t\tIPriceFeed _priceFeed = priceFeed;\n\t\treturn _priceFeed.fetchPrice(address(collateralToken));\n\t}\n\n\tfunction getTrove(address _borrower) external view override returns (Trove memory) {\n\t\treturn Troves[_borrower];\n\t}\n\n\tfunction getRewardSnapshots(address _borrower) external view override returns (RewardSnapshot memory) {\n\t\treturn rewardSnapshots[_borrower];\n\t}\n\n\tfunction getTroveOwnersCount() external view returns (uint256) {\n\t\treturn TroveOwners.length;\n\t}\n\n\tfunction getTroveFromTroveOwnersArray(uint256 _index) external view returns (address) {\n\t\treturn TroveOwners[_index];\n\t}\n\n\tfunction getTroveStatus(address _borrower) external view returns (uint256) {\n\t\treturn uint256(Troves[_borrower].status);\n\t}\n\n\tfunction getTroveStake(address _borrower) external view returns (uint256) {\n\t\treturn Troves[_borrower].stake;\n\t}\n\n\t/**\n        @notice Get the current total collateral and debt amounts for a trove\n        @dev Also includes pending rewards from redistribution\n     */\n\tfunction getTroveCollAndDebt(address _borrower) public view returns (uint256 coll, uint256 debt) {\n\t\t(debt, coll, , ) = getEntireDebtAndColl(_borrower);\n\t\treturn (coll, debt);\n\t}\n\n\t/**\n        @notice Get the total and pending collateral and debt amounts for a trove\n        @dev Used by the liquidation manager\n     */\n\tfunction getEntireDebtAndColl(address _borrower) public view returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollateralReward) {\n\t\tTrove storage t = Troves[_borrower];\n\t\tdebt = t.debt;\n\t\tcoll = t.coll;\n\t\t(pendingCollateralReward, pendingDebtReward) = getPendingCollAndDebtRewards(_borrower);\n\t\tdebt = debt + pendingDebtReward;\n\t\tcoll = coll + pendingCollateralReward;\n\t}\n\n\tfunction getEntireSystemColl() public view returns (uint256) {\n\t\treturn totalActiveCollateral + defaultedCollateral;\n\t}\n\n\tfunction getEntireSystemDebt() public view override(ITroveManager, InterestDebtPool) returns (uint256) {\n\t\treturn totalActiveDebt + defaultedDebt;\n\t}\n\n\tfunction getGlobalSystemDebt() public view returns (uint256) {\n\t\treturn totalActiveDebt + defaultedDebt + outstandingInterestDebt + getPendingSystemInterestDebt();\n\t}\n\n\tfunction getEntireSystemBalances() external returns (uint256, uint256, uint256) {\n\t\treturn (getEntireSystemColl(), getGlobalSystemDebt(), fetchPrice());\n\t}\n\n\t// --- Helper functions ---\n\n\t// Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n\tfunction getNominalICR(address _borrower) public view returns (uint256) {\n\t\t(uint256 currentCollateral, uint256 currentDebt) = getTroveCollAndDebt(_borrower);\n\n\t\tuint256 NICR = ZebraMath._computeNominalCR(currentCollateral, currentDebt);\n\t\treturn NICR;\n\t}\n\n\tfunction getRedemptionICR(address _borrower, uint256 _price) public view returns (uint256) {\n\t\t(uint256 currentCollateral, uint256 currentDebt) = getTroveCollAndDebt(_borrower);\n\t\tuint256 ICR = ZebraMath._computeCR(currentCollateral, currentDebt, _price);\n\t\treturn ICR;\n\t}\n\n\t// Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n\tfunction getCurrentICR(address _borrower, uint256 _price) public view returns (uint256) {\n\t\t(uint256 currentCollateral, uint256 currentDebt) = getTroveCollAndDebt(_borrower);\n\t\tuint256 ICR = ZebraMath._computeCR(currentCollateral, currentDebt + getTroveInterest(_borrower, currentDebt), _price);\n\t\treturn ICR;\n\t}\n\n\tfunction getTroveInterest(address _borrower, uint256 debt) public view returns (uint256) {\n\t\treturn (debt * (getPendingInterestDebt() - rewardSnapshots[_borrower].interest)) / DECIMAL_PRECISION;\n\t}\n\n\tfunction getTotalActiveCollateral() public view returns (uint256) {\n\t\treturn totalActiveCollateral;\n\t}\n\n\tfunction getTotalActiveDebt() public view returns (uint256) {\n\t\treturn totalActiveDebt;\n\t}\n\n\t// Get the borrower's pending accumulated collateral and debt rewards, earned by their stake\n\tfunction getPendingCollAndDebtRewards(address _borrower) public view returns (uint256, uint256) {\n\t\tRewardSnapshot memory snapshot = rewardSnapshots[_borrower];\n\n\t\tuint256 coll = L_collateral - snapshot.collateral;\n\t\tuint256 debt = L_debt - snapshot.debt;\n\n\t\tif (coll + debt == 0 || Troves[_borrower].status != Status.active) return (0, 0);\n\n\t\tuint256 stake = Troves[_borrower].stake;\n\t\treturn ((stake * coll) / DECIMAL_PRECISION, (stake * debt) / DECIMAL_PRECISION);\n\t}\n\n\tfunction hasPendingRewards(address _borrower) public view returns (bool) {\n\t\t/*\n\t\t * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n\t\t * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n\t\t * pending rewards\n\t\t */\n\t\tif (Troves[_borrower].status != Status.active) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (rewardSnapshots[_borrower].collateral < L_collateral);\n\t}\n\n\t// --- Redemption fee functions ---\n\n\t/*\n\t * This function has two impacts on the baseRate state variable:\n\t * 1) decays the baseRate based on time passed since last redemption or debt borrowing operation.\n\t * then,\n\t * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n\t */\n\tfunction _updateBaseRateFromRedemption(uint256 _collateralDrawn, uint256 _price, uint256 _totalDebtSupply) internal returns (uint256) {\n\t\tuint256 decayedBaseRate = _calcDecayedBaseRate();\n\n\t\t/* Convert the drawn collateral back to debt at face value rate (1 debt:1 USD), in order to get\n\t\t * the fraction of total supply that was redeemed at face value. */\n\t\tuint256 redeemedDebtFraction = (_collateralDrawn * _price) / _totalDebtSupply;\n\t\tuint256 newBaseRate = decayedBaseRate + (redeemedDebtFraction / BETA);\n\t\tnewBaseRate = ZebraMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n\n\t\t// Update the baseRate state variable\n\t\tbaseRate = newBaseRate;\n\t\temit BaseRateUpdated(newBaseRate);\n\n\t\t_updateLastFeeOpTime();\n\n\t\treturn newBaseRate;\n\t}\n\n\tfunction getRedemptionRate() public view returns (uint256) {\n\t\treturn _calcRedemptionRate(baseRate);\n\t}\n\n\tfunction getRedemptionRateWithDecay() public view returns (uint256) {\n\t\treturn _calcRedemptionRate(_calcDecayedBaseRate());\n\t}\n\n\tfunction _calcRedemptionRate(uint256 _baseRate) internal view returns (uint256) {\n\t\treturn\n\t\t\tZebraMath._min(\n\t\t\t\tredemptionFeeFloor + _baseRate,\n\t\t\t\tmaxRedemptionFee // cap at a maximum of 100%\n\t\t\t);\n\t}\n\n\tfunction getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256) {\n\t\treturn _calcRedemptionFee(getRedemptionRateWithDecay(), _collateralDrawn);\n\t}\n\n\tfunction _calcRedemptionFee(uint256 _redemptionRate, uint256 _collateralDrawn) internal pure returns (uint256) {\n\t\tuint256 redemptionFee = (_redemptionRate * _collateralDrawn) / DECIMAL_PRECISION;\n\t\trequire(redemptionFee < _collateralDrawn, \"Fee exceeds returned collateral\");\n\t\treturn redemptionFee;\n\t}\n\n\t// --- Borrowing fee functions ---\n\n\tfunction getBorrowingRate() public view returns (uint256) {\n\t\treturn _calcBorrowingRate(baseRate);\n\t}\n\n\tfunction getBorrowingRateWithDecay() public view returns (uint256) {\n\t\treturn _calcBorrowingRate(_calcDecayedBaseRate());\n\t}\n\n\tfunction _calcBorrowingRate(uint256 _baseRate) internal view returns (uint256) {\n\t\treturn ZebraMath._min(borrowingFeeFloor + _baseRate, maxBorrowingFee);\n\t}\n\n\tfunction getBorrowingFee(uint256 _debt) external view returns (uint256) {\n\t\treturn _calcBorrowingFee(getBorrowingRate(), _debt);\n\t}\n\n\tfunction getBorrowingFeeWithDecay(uint256 _debt) external view returns (uint256) {\n\t\treturn _calcBorrowingFee(getBorrowingRateWithDecay(), _debt);\n\t}\n\n\tfunction _calcBorrowingFee(uint256 _borrowingRate, uint256 _debt) internal pure returns (uint256) {\n\t\treturn (_borrowingRate * _debt) / DECIMAL_PRECISION;\n\t}\n\n\t// --- Internal fee functions ---\n\n\t// Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n\tfunction _updateLastFeeOpTime() internal {\n\t\tuint256 timePassed = block.timestamp - lastFeeOperationTime;\n\n\t\tif (timePassed >= SECONDS_IN_ONE_MINUTE) {\n\t\t\tlastFeeOperationTime = block.timestamp;\n\t\t\temit LastFeeOpTimeUpdated(block.timestamp);\n\t\t}\n\t}\n\n\tfunction _calcDecayedBaseRate() internal view returns (uint256) {\n\t\tuint256 minutesPassed = (block.timestamp - lastFeeOperationTime) / SECONDS_IN_ONE_MINUTE;\n\t\tuint256 decayFactor = ZebraMath._decPow(minuteDecayFactor, minutesPassed);\n\n\t\treturn (baseRate * decayFactor) / DECIMAL_PRECISION;\n\t}\n\n\t// --- Redemption functions ---\n\n\t/* Send _debtAmount debt to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n\t * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n\t *\n\t * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n\t * splitting the total _amount in appropriate chunks and calling the function multiple times.\n\t *\n\t * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n\t * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n\t * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n\t * costs can vary.\n\t *\n\t * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n\t * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n\t * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n\t * in the sortedTroves list along with the ICR value that the hint was found for.\n\t *\n\t * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n\t * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n\t * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining debt amount, which they can attempt\n\t * to redeem later.\n\t */\n\tfunction redeemCollateral(uint256 _debtAmount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint256 _partialRedemptionHintNICR, uint256 _maxIterations, uint256 _maxFeePercentage) external {\n\t\tISortedTroves _sortedTrovesCached = sortedTroves;\n\t\tRedemptionTotals memory totals;\n\n\t\trequire(_maxFeePercentage >= redemptionFeeFloor && _maxFeePercentage <= maxRedemptionFee, \"Max fee 0.5% to 100%\");\n\t\trequire(block.timestamp >= systemDeploymentTime + BOOTSTRAP_PERIOD, \"BOOTSTRAP_PERIOD\");\n\t\t_distributeInterestDebt();\n\t\ttotals.price = fetchPrice();\n\t\tuint256 _MCR = MCR;\n\t\trequire(IBorrowerOperations(borrowerOperationsAddress).getTCR() >= _MCR, \"Cannot redeem when TCR < MCR\");\n\t\trequire(_debtAmount > 0, \"Amount must be greater than zero\");\n\t\trequire(ZebraUSD.balanceOf(msg.sender) >= _debtAmount, \"Insufficient balance\");\n\t\ttotals.totalDebtSupplyAtStart = getGlobalSystemDebt();\n\n\t\ttotals.remainingDebt = _debtAmount;\n\t\taddress currentBorrower;\n\n\t\tif (_isValidFirstRedemptionHint(_sortedTrovesCached, _firstRedemptionHint, totals.price, _MCR)) {\n\t\t\tcurrentBorrower = _firstRedemptionHint;\n\t\t} else {\n\t\t\tcurrentBorrower = _sortedTrovesCached.getLast();\n\t\t\t// Find the first trove with ICR >= MCR\n\t\t\twhile (currentBorrower != address(0) && getRedemptionICR(currentBorrower, totals.price) < _MCR) {\n\t\t\t\tcurrentBorrower = _sortedTrovesCached.getPrev(currentBorrower);\n\t\t\t}\n\t\t}\n\n\t\t// Loop through the Troves starting from the one with lowest collateral ratio until _amount of debt is exchanged for collateral\n\t\tif (_maxIterations == 0) {\n\t\t\t_maxIterations = type(uint256).max;\n\t\t}\n\t\twhile (currentBorrower != address(0) && totals.remainingDebt > 0 && _maxIterations > 0) {\n\t\t\t_maxIterations--;\n\t\t\t// Save the address of the Trove preceding the current one, before potentially modifying the list\n\t\t\taddress nextUserToCheck = _sortedTrovesCached.getPrev(currentBorrower);\n\n\t\t\t_applyPendingRewards(currentBorrower);\n\t\t\tSingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(_sortedTrovesCached, currentBorrower, totals.remainingDebt, totals.price, _upperPartialRedemptionHint, _lowerPartialRedemptionHint, _partialRedemptionHintNICR);\n\n\t\t\tif (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n\t\t\ttotals.totalDebtToRedeem = totals.totalDebtToRedeem + singleRedemption.debtLot;\n\t\t\ttotals.totalCollateralDrawn = totals.totalCollateralDrawn + singleRedemption.collateralLot;\n\t\t\ttotals.totalInterest = totals.totalInterest + singleRedemption.interestLot;\n\n\t\t\ttotals.remainingDebt = totals.remainingDebt - singleRedemption.debtLot;\n\t\t\tcurrentBorrower = nextUserToCheck;\n\t\t}\n\t\trequire(totals.totalCollateralDrawn > 0, \"Unable to redeem any amount\");\n\n\t\t// Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n\t\t// Use the saved total debt supply value, from before it was reduced by the redemption.\n\t\t_updateBaseRateFromRedemption(totals.totalCollateralDrawn, totals.price, totals.totalDebtSupplyAtStart);\n\t\t// Calculate the collateral fee\n\t\ttotals.collateralFee = sunsetting ? 0 : _calcRedemptionFee(getRedemptionRate(), totals.totalCollateralDrawn);\n\t\t_requireUserAcceptsFee(totals.collateralFee, totals.totalCollateralDrawn, _maxFeePercentage);\n\n\t\t_sendCollateral(feeReceiver(), totals.collateralFee);\n\n\t\ttotals.collateralToSendToRedeemer = totals.totalCollateralDrawn - totals.collateralFee;\n\n\t\temit Redemption(_debtAmount, totals.totalDebtToRedeem, totals.totalCollateralDrawn, totals.totalInterest, totals.collateralFee);\n\n\t\t// Burn the total debt that is cancelled with debt, and send the redeemed collateral to msg.sender\n\t\tZebraUSD.burn(msg.sender, totals.totalDebtToRedeem);\n\t\t// Update Trove Manager debt, and send collateral to account\n\t\ttotalActiveDebt = totalActiveDebt - totals.totalDebtToRedeem;\n\t\tdecreaseOutstandingInterestDebt(totals.totalInterest);\n\t\t_sendCollateral(msg.sender, totals.collateralToSendToRedeemer);\n\t\t_resetState();\n\t}\n\n\t// Redeem as much collateral as possible from _borrower's Trove in exchange for debt up to _maxDebtAmount\n\tfunction _redeemCollateralFromTrove(\n\t\tISortedTroves _sortedTrovesCached,\n\t\taddress _borrower,\n\t\tuint256 _maxDebtAmount,\n\t\tuint256 _price,\n\t\taddress _upperPartialRedemptionHint,\n\t\taddress _lowerPartialRedemptionHint,\n\t\tuint256 _partialRedemptionHintNICR\n\t) internal returns (SingleRedemptionValues memory singleRedemption) {\n\t\tTrove storage t = Troves[_borrower];\n\t\tuint256 interest = getTroveInterest(_borrower, t.debt);\n\t\tif (_maxDebtAmount < interest) {\n\t\t\tsingleRedemption.cancelledPartial = true;\n\t\t\treturn singleRedemption;\n\t\t}\n\t\tsingleRedemption.interestLot = interest;\n\t\t// Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n\t\tsingleRedemption.debtLot = ZebraMath._min(_maxDebtAmount - singleRedemption.interestLot, t.debt - DEBT_GAS_COMPENSATION);\n\n\t\t// Get the CollateralLot of equivalent value in USD\n\t\tsingleRedemption.collateralLot = ((singleRedemption.debtLot + singleRedemption.interestLot) * DECIMAL_PRECISION) / _price;\n\t\t// Decrease the debt and collateral of the current Trove according to the debt lot and corresponding collateral to send\n\t\tuint256 newDebt = (t.debt) - singleRedemption.debtLot;\n\t\tuint256 newColl = (t.coll) - singleRedemption.collateralLot;\n\n\t\tif (newDebt == DEBT_GAS_COMPENSATION) {\n\t\t\t// No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n\t\t\t_removeStake(_borrower);\n\t\t\t_closeTrove(_borrower, Status.closedByRedemption);\n\t\t\t_redeemCloseTrove(_borrower, DEBT_GAS_COMPENSATION, newColl);\n\t\t\temit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.redeemCollateral);\n\t\t} else {\n\t\t\tuint256 newNICR = ZebraMath._computeNominalCR(newColl, newDebt);\n\t\t\t/*\n\t\t\t * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n\t\t\t * certainly result in running out of gas.\n\t\t\t *\n\t\t\t * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n\t\t\t */\n\n\t\t\t{\n\t\t\t\t// We check if the ICR hint is reasonable up to date, with continuous interest there might be slight differences (<1bps)\n\t\t\t\tuint256 icrError = _partialRedemptionHintNICR > newNICR ? _partialRedemptionHintNICR - newNICR : newNICR - _partialRedemptionHintNICR;\n\t\t\t\tif (icrError > 5e14 || _getNetDebt(newDebt) < IBorrowerOperations(borrowerOperationsAddress).minNetDebt()) {\n\t\t\t\t\tsingleRedemption.cancelledPartial = true;\n\t\t\t\t\treturn singleRedemption;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_sortedTrovesCached.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\n\n\t\t\tt.debt = newDebt;\n\t\t\tt.coll = newColl;\n\t\t\t_updateStakeAndTotalStakes(t);\n\t\t\t_updateTroveRewardSnapshots(_borrower);\n\t\t\temit TroveUpdated(_borrower, newDebt, newColl, t.stake, TroveManagerOperation.redeemCollateral);\n\t\t}\n\n\t\treturn singleRedemption;\n\t}\n\n\t/*\n\t * Called when a full redemption occurs, and closes the trove.\n\t * The redeemer swaps (debt - liquidation reserve) debt for (debt - liquidation reserve) worth of collateral, so the debt liquidation reserve left corresponds to the remaining debt.\n\t * In order to close the trove, the debt liquidation reserve is burned, and the corresponding debt is removed.\n\t * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n\t * Any surplus collateral left in the trove can be later claimed by the borrower.\n\t */\n\tfunction _redeemCloseTrove(address _borrower, uint256 _debt, uint256 _collateral) internal {\n\t\tZebraUSD.burn(gasPoolAddress, _debt);\n\t\ttotalActiveDebt = totalActiveDebt - _debt;\n\n\t\tsurplusBalances[_borrower] += _collateral;\n\t\ttotalActiveCollateral -= _collateral;\n\t}\n\n\tfunction _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint256 _price, uint256 _MCR) internal view returns (bool) {\n\t\tif (_firstRedemptionHint == address(0) || !_sortedTroves.contains(_firstRedemptionHint) || getRedemptionICR(_firstRedemptionHint, _price) < _MCR) {\n\t\t\treturn false;\n\t\t}\n\n\t\taddress nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\n\t\treturn nextTrove == address(0) || getRedemptionICR(nextTrove, _price) < _MCR;\n\t}\n\n\t/**\n\t * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n\t */\n\tfunction claimCollateral(address _receiver) external {\n\t\tuint256 claimableColl = surplusBalances[msg.sender];\n\t\trequire(claimableColl > 0, \"No collateral available to claim\");\n\n\t\tsurplusBalances[msg.sender] = 0;\n\n\t\tcollateralToken.safeTransfer(_receiver, claimableColl);\n\t}\n\n\t// --- Trove Adjustment functions ---\n\n\tfunction openTrove(address _borrower, uint256 _collateralAmount, uint256 _compositeDebt, uint256 NICR, address _upperHint, address _lowerHint) external whenNotPaused returns (uint256 stake, uint256 arrayIndex) {\n\t\t_requireCallerIsBO();\n\t\trequire(!sunsetting, \"Cannot open while sunsetting\");\n\t\tuint256 supply = totalActiveDebt;\n\t\tTrove storage t = Troves[_borrower];\n\t\trequire(t.status != Status.active, \"BorrowerOps: Trove is active\");\n\t\tt.status = Status.active;\n\t\tt.coll = _collateralAmount;\n\t\tt.debt = _compositeDebt;\n\t\t_updateTroveRewardSnapshots(_borrower);\n\t\tstake = _updateStakeAndTotalStakes(t);\n\t\tsortedTroves.insert(_borrower, NICR, _upperHint, _lowerHint);\n\n\t\tTroveOwners.push(_borrower);\n\t\tarrayIndex = TroveOwners.length - 1;\n\t\tt.arrayIndex = uint128(arrayIndex);\n\n\t\ttotalActiveCollateral = totalActiveCollateral + _collateralAmount;\n\t\tuint256 _newTotalDebt = supply + _compositeDebt;\n\t\trequire(_newTotalDebt + defaultedDebt <= maxSystemDebt, \"Collateral debt limit reached\");\n\t\ttotalActiveDebt = _newTotalDebt;\n\t}\n\n\tfunction updateTroveFromAdjustment(bool _isDebtIncrease, uint256 _debtChange, uint256 _netDebtChange, bool _isCollIncrease, uint256 _collChange, address _upperHint, address _lowerHint, address _borrower, address _receiver) external returns (uint256, uint256, uint256) {\n\t\t_requireCallerIsBO();\n\t\tif (_isCollIncrease || _isDebtIncrease) {\n\t\t\trequire(!paused, \"Collateral Paused\");\n\t\t\trequire(!sunsetting, \"Cannot increase while sunsetting\");\n\t\t}\n\n\t\tTrove storage t = Troves[_borrower];\n\t\trequire(t.status == Status.active, \"Trove closed or does not exist\");\n\n\t\tuint256 newDebt = t.debt;\n\t\tif (_debtChange > 0) {\n\t\t\tif (_isDebtIncrease) {\n\t\t\t\tnewDebt = newDebt + _netDebtChange;\n\t\t\t\t_increaseDebt(_receiver, _netDebtChange, _debtChange);\n\t\t\t} else {\n\t\t\t\tnewDebt = newDebt - _netDebtChange;\n\t\t\t\t_decreaseDebt(_receiver, _debtChange);\n\t\t\t}\n\t\t\tt.debt = newDebt;\n\t\t}\n\n\t\tuint256 newColl = t.coll;\n\t\tif (_collChange > 0) {\n\t\t\tif (_isCollIncrease) {\n\t\t\t\tnewColl = newColl + _collChange;\n\t\t\t\ttotalActiveCollateral = totalActiveCollateral + _collChange;\n\t\t\t\t// trust that BorrowerOperations sent the collateral\n\t\t\t} else {\n\t\t\t\tnewColl = newColl - _collChange;\n\t\t\t\t_sendCollateral(_receiver, _collChange);\n\t\t\t}\n\t\t\tt.coll = newColl;\n\t\t}\n\n\t\tuint256 newNICR = ZebraMath._computeNominalCR(newColl, newDebt);\n\t\tsortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n\t\treturn (newColl, newDebt, _updateStakeAndTotalStakes(t));\n\t}\n\n\tfunction closeTrove(address _borrower, address _receiver, uint256 collAmount, uint256 debtAmount) external {\n\t\t_requireCallerIsBO();\n\t\trequire(Troves[_borrower].status == Status.active, \"Trove closed or does not exist\");\n\t\t_removeStake(_borrower);\n\t\t_closeTrove(_borrower, Status.closedByOwner);\n\t\ttotalActiveDebt = totalActiveDebt - debtAmount;\n\t\t_sendCollateral(_receiver, collAmount);\n\t\t_resetState();\n\t}\n\n\t/**\n        @dev Only called from `closeTrove` because liquidating the final trove is blocked in\n             `LiquidationManager`. Many liquidation paths involve redistributing debt and\n             collateral to existing troves. If the collateral is being sunset, the final trove\n             must be closed by repaying the debt or via a redemption.\n     */\n\tfunction _resetState() private {\n\t\tif (TroveOwners.length == 0) {\n\t\t\tlastInterestDebtUpdateTime = 0;\n\t\t\ttotalStakes = 0;\n\t\t\ttotalStakesSnapshot = 0;\n\t\t\ttotalCollateralSnapshot = 0;\n\t\t\tL_collateral = 0;\n\t\t\tL_debt = 0;\n\t\t\tL_Interest_Debt = 0;\n\t\t\tlastInterestDebtError_Redistribution = 0;\n\t\t\tlastCollateralError_Redistribution = 0;\n\t\t\tlastDebtError_Redistribution = 0;\n\t\t\ttotalActiveCollateral = 0;\n\t\t\ttotalActiveDebt = 0;\n\t\t\tdefaultedCollateral = 0;\n\t\t\tdefaultedDebt = 0;\n\t\t\toutstandingInterestDebt = 0;\n\t\t}\n\t}\n\n\tfunction _closeTrove(address _borrower, Status closedStatus) internal {\n\t\tuint256 TroveOwnersArrayLength = TroveOwners.length;\n\n\t\tTrove storage t = Troves[_borrower];\n\t\tt.status = closedStatus;\n\t\tt.coll = 0;\n\t\tt.debt = 0;\n\t\tISortedTroves sortedTrovesCached = sortedTroves;\n\t\trewardSnapshots[_borrower].collateral = 0;\n\t\trewardSnapshots[_borrower].debt = 0;\n\t\tif (TroveOwnersArrayLength > 1 && sortedTrovesCached.getSize() > 1) {\n\t\t\t// remove trove owner from the TroveOwners array, not preserving array order\n\t\t\tuint128 index = t.arrayIndex;\n\t\t\taddress addressToMove = TroveOwners[TroveOwnersArrayLength - 1];\n\t\t\tTroveOwners[index] = addressToMove;\n\t\t\tTroves[addressToMove].arrayIndex = index;\n\t\t\temit TroveIndexUpdated(addressToMove, index);\n\t\t}\n\n\t\tTroveOwners.pop();\n\n\t\tsortedTrovesCached.remove(_borrower);\n\t\tt.arrayIndex = 0;\n\t}\n\n\t// Updates the baseRate state variable based on time elapsed since the last redemption or debt borrowing operation.\n\tfunction decayBaseRateAndGetBorrowingFee(uint256 _debt) external returns (uint256) {\n\t\t_requireCallerIsBO();\n\t\tuint256 rate = _decayBaseRate();\n\n\t\treturn _calcBorrowingFee(_calcBorrowingRate(rate), _debt);\n\t}\n\n\tfunction _decayBaseRate() internal returns (uint256) {\n\t\tuint256 decayedBaseRate = _calcDecayedBaseRate();\n\n\t\tbaseRate = decayedBaseRate;\n\t\temit BaseRateUpdated(decayedBaseRate);\n\n\t\t_updateLastFeeOpTime();\n\n\t\treturn decayedBaseRate;\n\t}\n\n\tfunction applyPendingRewards(address _borrower) external returns (uint256 coll, uint256 debt) {\n\t\t_requireCallerIsBO();\n\t\treturn _applyPendingRewards(_borrower);\n\t}\n\n\t// Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n\tfunction _applyPendingRewards(address _borrower) internal returns (uint256, uint256) {\n\t\tTrove storage t = Troves[_borrower];\n\t\tif (t.status == Status.active) {\n\t\t\t(uint256 pendingCollateralReward, uint256 pendingDebtReward) = getPendingCollAndDebtRewards(_borrower);\n\t\t\t// Apply pending rewards to trove's state\n\t\t\tt.coll += pendingCollateralReward;\n\t\t\tt.debt += pendingDebtReward;\n\n\t\t\t_updateTroveRewardSnapshots(_borrower);\n\n\t\t\t_movePendingTroveRewardsToActiveBalance(pendingDebtReward, pendingCollateralReward);\n\n\t\t\temit TroveUpdated(_borrower, t.debt, t.coll, t.stake, TroveManagerOperation.applyPendingRewards);\n\t\t}\n\t\treturn (t.coll, t.debt);\n\t}\n\n\tfunction _updateTroveRewardSnapshots(address _borrower) internal {\n\t\tuint256 L_collateralCached = L_collateral;\n\t\tuint256 L_debtCached = L_debt;\n\t\tuint256 L_InterestDebtCached = L_Interest_Debt;\n\t\trewardSnapshots[_borrower] = RewardSnapshot(L_collateralCached, L_debtCached, L_InterestDebtCached);\n\t\temit TroveSnapshotsUpdated(L_collateralCached, L_debtCached, L_InterestDebtCached);\n\t}\n\n\tfunction repayInterestDebt(address _borrower) external {\n\t\t_distributeInterestDebt();\n\t\t_applyPendingRewards(_borrower);\n\t\t(uint256 debt, , , ) = getEntireDebtAndColl(_borrower);\n\t\t_repayInterest(msg.sender, _borrower, debt);\n\t}\n\n\tfunction repayInterest(address _account, address _borrower, uint256 _debt) public {\n\t\t_requireCallerIsBO();\n\t\t_repayInterest(_account, _borrower, _debt);\n\t}\n\n\tfunction _repayInterest(address _account, address _borrower, uint256 _debt) internal {\n\t\tuint256 interest = getTroveInterest(_borrower, _debt);\n\t\tif (ZebraUSD.balanceOf(_account) >= interest) {\n\t\t\tZebraUSD.burn(_account, interest);\n\t\t} else {\n\t\t\ttotalActiveDebt += interest;\n\t\t\tTroves[_borrower].debt += interest;\n\t\t}\n\t\tdecreaseOutstandingInterestDebt(interest);\n\t\t_updateTroveRewardSnapshots(_borrower);\n\t\temit InsterstPaid(_account, _borrower, interest);\n\t}\n\n\t// Remove borrower's stake from the totalStakes sum, and set their stake to 0\n\tfunction _removeStake(address _borrower) internal {\n\t\tuint256 stake = Troves[_borrower].stake;\n\t\ttotalStakes = totalStakes - stake;\n\t\tTroves[_borrower].stake = 0;\n\t}\n\n\t// Update borrower's stake based on their latest collateral value\n\tfunction _updateStakeAndTotalStakes(Trove storage t) internal returns (uint256) {\n\t\tuint256 newStake = _computeNewStake(t.coll);\n\t\tuint256 oldStake = t.stake;\n\t\tt.stake = newStake;\n\t\tuint256 newTotalStakes = totalStakes - oldStake + newStake;\n\t\ttotalStakes = newTotalStakes;\n\t\temit TotalStakesUpdated(newTotalStakes);\n\n\t\treturn newStake;\n\t}\n\n\t// Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n\tfunction _computeNewStake(uint256 _coll) internal view returns (uint256) {\n\t\tuint256 stake;\n\t\tuint256 totalCollateralSnapshotCached = totalCollateralSnapshot;\n\t\tif (totalCollateralSnapshotCached == 0) {\n\t\t\tstake = _coll;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The following assert() holds true because:\n\t\t\t * - The system always contains >= 1 trove\n\t\t\t * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n\t\t\t * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n\t\t\t */\n\t\t\tuint256 totalStakesSnapshotCached = totalStakesSnapshot;\n\t\t\tassert(totalStakesSnapshotCached > 0);\n\t\t\tstake = (_coll * totalStakesSnapshotCached) / totalCollateralSnapshotCached;\n\t\t}\n\t\treturn stake;\n\t}\n\n\tfunction closeLastTroveWhenSunsetting() external onlyOwner {\n\t\trequire(sunsetting, \"Not in sunsetting\");\n\t\trequire(TroveOwners.length == 1, \"Can only force to close last trove\");\n\t\taddress _borrower = TroveOwners[0];\n\t\tuint256 ICR = getCurrentICR(_borrower, fetchPrice());\n\t\tuint256 TCR = IBorrowerOperations(borrowerOperationsAddress).getTCR();\n\t\trequire(ICR < 1e18 || TCR < MCR, \"Can only force close bad borrower\");\n\t\t(uint256 coll, uint256 debt) = getTroveCollAndDebt(_borrower);\n\t\tuint256 interest = getTroveInterest(_borrower, debt);\n\t\ttotalActiveDebt = totalActiveDebt - debt;\n\t\ttotalActiveCollateral = totalActiveCollateral - coll;\n\t\tZebraUSD.burn(msg.sender, debt + interest);\n\t\t_sendCollateral(msg.sender, coll);\n\t\t_removeStake(_borrower);\n\t\t_closeTrove(_borrower, Status.closedByOwner);\n\t\t_resetState();\n\t}\n\n\t// --- Liquidation Functions ---\n\n\tfunction closeTroveByLiquidation(address _borrower) external {\n\t\t_requireCallerIsLM();\n\t\t_removeStake(_borrower);\n\t\t_closeTrove(_borrower, Status.closedByLiquidation);\n\t}\n\n\tfunction movePendingTroveRewardsToActiveBalances(uint256 _debt, uint256 _collateral) external {\n\t\t_requireCallerIsLM();\n\t\t_movePendingTroveRewardsToActiveBalance(_debt, _collateral);\n\t}\n\n\tfunction _movePendingTroveRewardsToActiveBalance(uint256 _debt, uint256 _collateral) internal {\n\t\tdefaultedDebt -= _debt;\n\t\ttotalActiveDebt += _debt;\n\t\tdefaultedCollateral -= _collateral;\n\t\ttotalActiveCollateral += _collateral;\n\t}\n\n\tfunction addCollateralSurplus(address borrower, uint256 collSurplus) external {\n\t\t_requireCallerIsLM();\n\t\tsurplusBalances[borrower] += collSurplus;\n\t}\n\n\tfunction finalizeLiquidation(address _liquidator, uint256 _debt, uint256 _coll, uint256 _collSurplus, uint256 _debtGasComp, uint256 _collGasComp, uint256 _interest) external {\n\t\t_requireCallerIsLM();\n\t\t// redistribute debt and collateral\n\t\t_redistributeDebtAndColl(_debt, _coll);\n\n\t\tuint256 _activeColl = totalActiveCollateral;\n\t\tif (_collSurplus > 0) {\n\t\t\t_activeColl -= _collSurplus;\n\t\t\ttotalActiveCollateral = _activeColl;\n\t\t}\n\n\t\t// update system snapshos\n\t\ttotalStakesSnapshot = totalStakes;\n\t\ttotalCollateralSnapshot = _activeColl - _collGasComp + defaultedCollateral;\n\t\temit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\n\t\tdecreaseOutstandingInterestDebt(_interest);\n\t\t// send gas compensation\n\t\tZebraUSD.returnFromPool(gasPoolAddress, _liquidator, _debtGasComp);\n\t\t_sendCollateral(_liquidator, _collGasComp);\n\t}\n\n\tfunction _redistributeDebtAndColl(uint256 _debt, uint256 _coll) internal {\n\t\tif (_debt == 0) {\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n\t\t * error correction, to keep the cumulative error low in the running totals L_collateral and L_debt:\n\t\t *\n\t\t * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n\t\t * function was called.\n\t\t * 2) Calculate \"per-unit-staked\" ratios.\n\t\t * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n\t\t * 4) Store these errors for use in the next correction when this function is called.\n\t\t * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n\t\t */\n\t\tuint256 collateralNumerator = (_coll * DECIMAL_PRECISION) + lastCollateralError_Redistribution;\n\t\tuint256 debtNumerator = (_debt * DECIMAL_PRECISION) + lastDebtError_Redistribution;\n\t\tuint256 totalStakesCached = totalStakes;\n\t\t// Get the per-unit-staked terms\n\t\tuint256 collateralRewardPerUnitStaked = collateralNumerator / totalStakesCached;\n\t\tuint256 debtRewardPerUnitStaked = debtNumerator / totalStakesCached;\n\n\t\tlastCollateralError_Redistribution = collateralNumerator - (collateralRewardPerUnitStaked * totalStakesCached);\n\t\tlastDebtError_Redistribution = debtNumerator - (debtRewardPerUnitStaked * totalStakesCached);\n\n\t\t// Add per-unit-staked terms to the running totals\n\t\tuint256 new_L_collateral = L_collateral + collateralRewardPerUnitStaked;\n\t\tuint256 new_L_debt = L_debt + debtRewardPerUnitStaked;\n\t\tL_collateral = new_L_collateral;\n\t\tL_debt = new_L_debt;\n\n\t\temit LTermsUpdated(new_L_collateral, new_L_debt);\n\n\t\ttotalActiveDebt -= _debt;\n\t\tdefaultedDebt += _debt;\n\t\tdefaultedCollateral += _coll;\n\t\ttotalActiveCollateral -= _coll;\n\t}\n\n\t// --- Trove property setters ---\n\n\tfunction _sendCollateral(address _account, uint256 _amount) private {\n\t\tif (_amount > 0) {\n\t\t\ttotalActiveCollateral = totalActiveCollateral - _amount;\n\t\t\temit CollateralSent(_account, _amount);\n\n\t\t\tcollateralToken.safeTransfer(_account, _amount);\n\t\t}\n\t}\n\n\tfunction _increaseDebt(address account, uint256 netDebtAmount, uint256 debtAmount) internal {\n\t\tuint256 _newTotalDebt = totalActiveDebt + netDebtAmount;\n\t\trequire(_newTotalDebt + defaultedDebt <= maxSystemDebt, \"Collateral debt limit reached\");\n\t\ttotalActiveDebt = _newTotalDebt;\n\t\tZebraUSD.mint(account, debtAmount);\n\t}\n\n\tfunction decreaseDebtAndSendCollateral(address account, uint256 debt, uint256 coll) external {\n\t\t_requireCallerIsLM();\n\t\t_decreaseDebt(account, debt);\n\t\t_sendCollateral(account, coll);\n\t}\n\n\tfunction _decreaseDebt(address account, uint256 amount) internal {\n\t\tZebraUSD.burn(account, amount);\n\t\ttotalActiveDebt = totalActiveDebt - amount;\n\t}\n\n\t// --- Requires ---\n\n\tfunction _requireCallerIsBO() internal view {\n\t\trequire(msg.sender == borrowerOperationsAddress, \"Caller not BO\");\n\t}\n\n\tfunction _requireCallerIsLM() internal view {\n\t\trequire(msg.sender == liquidationManager, \"Not Liquidation Manager\");\n\t}\n}\n"
    },
    "contracts/dependencies/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n// Buidler's helper contract for console logging\nlibrary console {\n\taddress public constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction loguint256(uint256 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n}\n"
    },
    "contracts/dependencies/DelegatedOps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/**\n    @title Zebra Delegated Operations\n    @notice Allows delegation to specific contract functionality. Useful for creating\n            wrapper contracts to bundle multiple interactions into a single call.\n\n            Functions that supports delegation should include an `account` input allowing\n            the delegated caller to indicate who they are calling on behalf of. In executing\n            the call, all internal state updates should be applied for `account` and all\n            value transfers should occur to or from the caller.\n\n            For example: a delegated call to `openTrove` should transfer collateral\n            from the caller, create the debt position for `account`, and send newly\n            minted tokens to the caller.\n */\ncontract DelegatedOps {\n\tmapping(address => mapping(address => bool)) public isApprovedDelegate;\n\n\tmodifier callerOrDelegated(address _account) {\n\t\trequire(msg.sender == _account || isApprovedDelegate[_account][msg.sender], \"Delegate not approved\");\n\t\t_;\n\t}\n\n\tfunction setDelegateApproval(address _delegate, bool _isApproved) external {\n\t\tisApprovedDelegate[msg.sender][_delegate] = _isApproved;\n\t}\n}\n"
    },
    "contracts/dependencies/SystemStart.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IZebraCore.sol\";\n\n/**\n    @title Zebra System Start Time\n    @dev Provides a unified `startTime` and `getWeek`, used for emissions.\n */\ncontract SystemStart {\n\tuint256 public immutable startTime;\n\n\tconstructor(IZebraCore ZebraCore) {\n\t\tstartTime = ZebraCore.startTime();\n\t}\n}\n"
    },
    "contracts/dependencies/ZebraBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"../interfaces/IZebraBase.sol\";\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\ncontract ZebraBase is IZebraBase {\n\tuint256 public constant override DECIMAL_PRECISION = 1e18;\n\n\t// Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n\tuint256 public constant override CCR = 2000000000000000000; // 200%\n\n\t// Amount of debt to be locked in gas pool on opening troves\n\tuint256 public immutable override DEBT_GAS_COMPENSATION;\n\n\tuint256 public constant override PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n\tconstructor(uint256 _gasCompensation) {\n\t\tDEBT_GAS_COMPENSATION = _gasCompensation;\n\t}\n\n\t// --- Gas compensation functions ---\n\n\t// Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n\tfunction _getCompositeDebt(uint256 _debt) internal view returns (uint256) {\n\t\treturn _debt + DEBT_GAS_COMPENSATION;\n\t}\n\n\tfunction _getNetDebt(uint256 _debt) internal view returns (uint256) {\n\t\treturn _debt - DEBT_GAS_COMPENSATION;\n\t}\n\n\t// Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.\n\tfunction _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {\n\t\treturn _entireColl / PERCENT_DIVISOR;\n\t}\n\n\tfunction _requireUserAcceptsFee(uint256 _fee, uint256 _amount, uint256 _maxFeePercentage) internal pure {\n\t\tuint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n\t\trequire(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\n\t}\n}\n"
    },
    "contracts/dependencies/ZebraMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nlibrary ZebraMath {\n\tuint256 internal constant DECIMAL_PRECISION = 1e18;\n\n\t/* Precision for Nominal ICR (independent of price). Rationale for the value:\n\t *\n\t * - Making it “too high” could lead to overflows.\n\t * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n\t *\n\t * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39,\n\t * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n\t *\n\t */\n\tuint256 internal constant NICR_PRECISION = 1e20;\n\n\tfunction _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn (_a < _b) ? _a : _b;\n\t}\n\n\tfunction _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn (_a >= _b) ? _a : _b;\n\t}\n\n\t/*\n\t * Multiply two decimal numbers and use normal rounding rules:\n\t * -round product up if 19'th mantissa digit >= 5\n\t * -round product down if 19'th mantissa digit < 5\n\t *\n\t * Used only inside the exponentiation, _decPow().\n\t */\n\tfunction decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\n\t\tuint256 prod_xy = x * y;\n\n\t\tdecProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\n\t}\n\n\t/*\n\t * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n\t *\n\t * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n\t *\n\t * TroveManager._calcDecayedBaseRate\n\t *\n\t * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n\t * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n\t *\n\t * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n\t * negligibly different from just passing the cap, since:\n\t *\n\t * the decayed base rate will be 0 for 1000 years or > 1000 years\n\t */\n\tfunction _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\n\t\tif (_minutes > 525600000) {\n\t\t\t_minutes = 525600000;\n\t\t} // cap to avoid overflow\n\n\t\tif (_minutes == 0) {\n\t\t\treturn DECIMAL_PRECISION;\n\t\t}\n\n\t\tuint256 y = DECIMAL_PRECISION;\n\t\tuint256 x = _base;\n\t\tuint256 n = _minutes;\n\n\t\t// Exponentiation-by-squaring\n\t\twhile (n > 1) {\n\t\t\tif (n % 2 == 0) {\n\t\t\t\tx = decMul(x, x);\n\t\t\t\tn = n / 2;\n\t\t\t} else {\n\t\t\t\t// if (n % 2 != 0)\n\t\t\t\ty = decMul(x, y);\n\t\t\t\tx = decMul(x, x);\n\t\t\t\tn = (n - 1) / 2;\n\t\t\t}\n\t\t}\n\n\t\treturn decMul(x, y);\n\t}\n\n\tfunction _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn (_a >= _b) ? _a - _b : _b - _a;\n\t}\n\n\tfunction _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\n\t\tif (_debt > 0) {\n\t\t\treturn (_coll * NICR_PRECISION) / _debt;\n\t\t}\n\t\t// Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n\t\telse {\n\t\t\t// if (_debt == 0)\n\t\t\treturn 2 ** 256 - 1;\n\t\t}\n\t}\n\n\tfunction _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint256) {\n\t\tif (_debt > 0) {\n\t\t\tuint256 newCollRatio = (_coll * _price) / _debt;\n\n\t\t\treturn newCollRatio;\n\t\t}\n\t\t// Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n\t\telse {\n\t\t\t// if (_debt == 0)\n\t\t\treturn type(uint256).max;\n\t\t}\n\t}\n\n\tfunction _computeCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\n\t\tif (_debt > 0) {\n\t\t\tuint256 newCollRatio = (_coll) / _debt;\n\n\t\t\treturn newCollRatio;\n\t\t}\n\t\t// Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n\t\telse {\n\t\t\t// if (_debt == 0)\n\t\t\treturn type(uint256).max;\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/ZebraOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IZebraCore.sol\";\n\n/**\n    @title Zebra Ownable\n    @notice Contracts inheriting `ZebraOwnable` have the same owner as `ZebraCore`.\n            The ownership cannot be independently modified or renounced.\n */\ncontract ZebraOwnable {\n\tIZebraCore public immutable ZebraCore;\n\n\tconstructor(IZebraCore _ZebraCore) {\n\t\tZebraCore = _ZebraCore;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner(), \"Only owner\");\n\t\t_;\n\t}\n\n\tmodifier onlyGuardian() {\n\t\trequire(msg.sender == guardian(), \"Only guardian\");\n\t\t_;\n\t}\n\n\tfunction owner() public view returns (address) {\n\t\treturn ZebraCore.owner();\n\t}\n\n\tfunction guardian() public view returns (address) {\n\t\treturn ZebraCore.guardian();\n\t}\n}\n"
    },
    "contracts/helpers/MultiCollateralHintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IFactory.sol\";\nimport \"../dependencies/ZebraBase.sol\";\nimport \"../dependencies/ZebraMath.sol\";\n\ncontract MultiCollateralHintHelpers is ZebraBase {\n\tIBorrowerOperations public immutable borrowerOperations;\n\n\tconstructor(address _borrowerOperationsAddress, uint256 _gasCompensation) ZebraBase(_gasCompensation) {\n\t\tborrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n\t}\n\n\t// --- Functions ---\n\n\t/* getRedemptionHints() - Helper function for finding the right hints to pass to redeemCollateral().\n\t *\n\t * It simulates a redemption of `_debtAmount` to figure out where the redemption sequence will start and what state the final Trove\n\t * of the sequence will end up in.\n\t *\n\t * Returns three hints:\n\t *  - `firstRedemptionHint` is the address of the first Trove with ICR >= MCR (i.e. the first Trove that will be redeemed).\n\t *  - `partialRedemptionHintNICR` is the final nominal ICR of the last Trove of the sequence after being hit by partial redemption,\n\t *     or zero in case of no partial redemption.\n\t *  - `truncatedDebtAmount` is the maximum amount that can be redeemed out of the the provided `_debtAmount`. This can be lower than\n\t *    `_debtAmount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the\n\t *    minimum allowed value (i.e. MIN_NET_DEBT).\n\t *\n\t * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero\n\t * will leave it uncapped.\n\t */\n\n\tfunction getRedemptionHints(ITroveManager troveManager, uint256 _debtAmount, uint256 _price, uint256 _maxIterations) external view returns (address firstRedemptionHint, uint256 partialRedemptionHintNICR, uint256 truncatedDebtAmount) {\n\t\tISortedTroves sortedTrovesCached = ISortedTroves(troveManager.sortedTroves());\n\n\t\tuint256 remainingDebt = _debtAmount;\n\t\taddress currentTroveuser = sortedTrovesCached.getLast();\n\t\tuint256 MCR = troveManager.MCR();\n\n\t\twhile (currentTroveuser != address(0) && troveManager.getRedemptionICR(currentTroveuser, _price) < MCR) {\n\t\t\tcurrentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\n\t\t}\n\n\t\tfirstRedemptionHint = currentTroveuser;\n\n\t\tif (_maxIterations == 0) {\n\t\t\t_maxIterations = type(uint256).max;\n\t\t}\n\n\t\tuint256 minNetDebt = borrowerOperations.minNetDebt();\n\t\twhile (currentTroveuser != address(0) && remainingDebt > 0 && _maxIterations-- > 0) {\n\t\t\t(uint256 debt, uint256 coll, , ) = troveManager.getEntireDebtAndColl(currentTroveuser);\n\t\t\tuint256 interest = troveManager.getTroveInterest(currentTroveuser, debt);\n\t\t\tif (remainingDebt < interest) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuint256 netDebt = _getNetDebt(debt);\n\t\t\tif (netDebt > remainingDebt - interest) {\n\t\t\t\tif (netDebt > minNetDebt) {\n\t\t\t\t\tuint256 maxRedeemableDebt = ZebraMath._min(remainingDebt - interest, netDebt - minNetDebt);\n\n\t\t\t\t\tuint256 newColl = coll - (((maxRedeemableDebt + interest) * DECIMAL_PRECISION) / _price);\n\t\t\t\t\tuint256 newDebt = netDebt - maxRedeemableDebt;\n\n\t\t\t\t\tuint256 compositeDebt = _getCompositeDebt(newDebt);\n\t\t\t\t\tpartialRedemptionHintNICR = ZebraMath._computeNominalCR(newColl, compositeDebt);\n\n\t\t\t\t\tremainingDebt = remainingDebt - maxRedeemableDebt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tremainingDebt = remainingDebt - netDebt;\n\t\t\t}\n\n\t\t\tcurrentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\n\t\t}\n\n\t\ttruncatedDebtAmount = _debtAmount - remainingDebt;\n\t}\n\n\t/* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the\n    sortedTroves list from the correct insert position of the Trove to be inserted.\n\n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function\n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will\n    be <= sqrt(length) positions away from the correct insert position.\n    */\n\tfunction getApproxHint(ITroveManager troveManager, uint256 _CR, uint256 _numTrials, uint256 _inputRandomSeed) external view returns (address hintAddress, uint256 diff, uint256 latestRandomSeed) {\n\t\tISortedTroves sortedTroves = ISortedTroves(troveManager.sortedTroves());\n\t\tuint256 arrayLength = troveManager.getTroveOwnersCount();\n\n\t\tif (arrayLength == 0) {\n\t\t\treturn (address(0), 0, _inputRandomSeed);\n\t\t}\n\n\t\thintAddress = sortedTroves.getLast();\n\t\tdiff = ZebraMath._getAbsoluteDifference(_CR, troveManager.getNominalICR(hintAddress));\n\t\tlatestRandomSeed = _inputRandomSeed;\n\n\t\tuint256 i = 1;\n\n\t\twhile (i < _numTrials) {\n\t\t\tlatestRandomSeed = uint256(keccak256(abi.encodePacked(latestRandomSeed)));\n\n\t\t\tuint256 arrayIndex = latestRandomSeed % arrayLength;\n\t\t\taddress currentAddress = troveManager.getTroveFromTroveOwnersArray(arrayIndex);\n\t\t\tuint256 currentNICR = troveManager.getNominalICR(currentAddress);\n\n\t\t\t// check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n\t\t\tuint256 currentDiff = ZebraMath._getAbsoluteDifference(currentNICR, _CR);\n\n\t\t\tif (currentDiff < diff) {\n\t\t\t\tdiff = currentDiff;\n\t\t\t\thintAddress = currentAddress;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfunction computeNominalCR(uint256 _coll, uint256 _debt) external pure returns (uint256) {\n\t\treturn ZebraMath._computeNominalCR(_coll, _debt);\n\t}\n\n\tfunction computeCR(uint256 _coll, uint256 _debt, uint256 _price) external pure returns (uint256) {\n\t\treturn ZebraMath._computeCR(_coll, _debt, _price);\n\t}\n}\n"
    },
    "contracts/helpers/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IFactory.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the ZebraCore Zebra system. */\ncontract MultiTroveGetter {\n\tstruct CombinedTroveData {\n\t\taddress owner;\n\t\tuint256 debt;\n\t\tuint256 interest;\n\t\tuint256 coll;\n\t\tuint256 stake;\n\t\tuint256 pendingCollateral;\n\t\tuint256 pendingDebt;\n\t}\n\n\tfunction getMultipleSortedTroves(ITroveManager troveManager, int _startIdx, uint256 _count) external view returns (CombinedTroveData[] memory _troves) {\n\t\tISortedTroves sortedTroves = ISortedTroves(troveManager.sortedTroves());\n\t\tuint256 startIdx;\n\t\tbool descend;\n\n\t\tif (_startIdx >= 0) {\n\t\t\tstartIdx = uint256(_startIdx);\n\t\t\tdescend = true;\n\t\t} else {\n\t\t\tstartIdx = uint256(-(_startIdx + 1));\n\t\t\tdescend = false;\n\t\t}\n\n\t\tuint256 sortedTrovesSize = sortedTroves.getSize();\n\t\tif (startIdx >= sortedTrovesSize) {\n\t\t\t_troves = new CombinedTroveData[](0);\n\t\t} else {\n\t\t\tuint256 maxCount = sortedTrovesSize - startIdx;\n\t\t\tif (_count > maxCount) {\n\t\t\t\t_count = maxCount;\n\t\t\t}\n\n\t\t\tif (descend) {\n\t\t\t\t_troves = _getMultipleSortedTrovesFromHead(troveManager, sortedTroves, startIdx, _count);\n\t\t\t} else {\n\t\t\t\t_troves = _getMultipleSortedTrovesFromTail(troveManager, sortedTroves, startIdx, _count);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _getMultipleSortedTrovesFromHead(ITroveManager troveManager, ISortedTroves sortedTroves, uint256 _startIdx, uint256 _count) internal view returns (CombinedTroveData[] memory _troves) {\n\t\taddress currentTroveowner = sortedTroves.getFirst();\n\n\t\tfor (uint256 idx = 0; idx < _startIdx; ++idx) {\n\t\t\tcurrentTroveowner = sortedTroves.getNext(currentTroveowner);\n\t\t}\n\n\t\t_troves = new CombinedTroveData[](_count);\n\n\t\tfor (uint256 idx = 0; idx < _count; ++idx) {\n\t\t\t_troves[idx].owner = currentTroveowner;\n\n\t\t\tITroveManager.Trove memory trove = troveManager.getTrove(currentTroveowner);\n\t\t\t_troves[idx].debt = trove.debt;\n\t\t\t_troves[idx].coll = trove.coll;\n\t\t\t_troves[idx].stake = trove.stake;\n\t\t\t(_troves[idx].pendingCollateral, _troves[idx].pendingDebt) = troveManager.getPendingCollAndDebtRewards(currentTroveowner);\n\t\t\t_troves[idx].interest = troveManager.getTroveInterest(currentTroveowner, _troves[idx].debt + _troves[idx].pendingDebt);\n\t\t\tcurrentTroveowner = sortedTroves.getNext(currentTroveowner);\n\t\t}\n\t}\n\n\tfunction _getMultipleSortedTrovesFromTail(ITroveManager troveManager, ISortedTroves sortedTroves, uint256 _startIdx, uint256 _count) internal view returns (CombinedTroveData[] memory _troves) {\n\t\taddress currentTroveowner = sortedTroves.getLast();\n\n\t\tfor (uint256 idx = 0; idx < _startIdx; ++idx) {\n\t\t\tcurrentTroveowner = sortedTroves.getPrev(currentTroveowner);\n\t\t}\n\n\t\t_troves = new CombinedTroveData[](_count);\n\n\t\tfor (uint256 idx = 0; idx < _count; ++idx) {\n\t\t\t_troves[idx].owner = currentTroveowner;\n\t\t\tITroveManager.Trove memory trove = troveManager.getTrove(currentTroveowner);\n\t\t\t_troves[idx].debt = trove.debt;\n\t\t\t_troves[idx].coll = trove.coll;\n\t\t\t_troves[idx].stake = trove.stake;\n\n\t\t\t(_troves[idx].pendingCollateral, _troves[idx].pendingDebt) = troveManager.getPendingCollAndDebtRewards(currentTroveowner);\n\n\t\t\t_troves[idx].interest = troveManager.getTroveInterest(currentTroveowner, _troves[idx].debt + _troves[idx].pendingDebt);\n\n\t\t\tcurrentTroveowner = sortedTroves.getPrev(currentTroveowner);\n\t\t}\n\t}\n}\n"
    },
    "contracts/helpers/TroveManagerGetters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IFactory.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the ZebraCore Zebra system. */\ncontract TroveManagerGetters {\n\tstruct Collateral {\n\t\tIERC20 collateral;\n\t\taddress[] troveManagers;\n\t}\n\n\tIFactory public immutable factory;\n\n\tconstructor(IFactory _factory) {\n\t\tfactory = _factory;\n\t}\n\n\t/**\n        @notice Returns all active system trove managers and collaterals, as an\n        `       array of tuples of [(collateral, [troveManager, ...]), ...]\n     */\n\tfunction getAllCollateralsAndTroveManagers() external view returns (Collateral[] memory) {\n\t\tuint256 length = factory.troveManagerCount();\n\t\taddress[2][] memory troveManagersAndCollaterals = new address[2][](length);\n\t\taddress[] memory uniqueCollaterals = new address[](length);\n\t\tuint256 collateralCount;\n\t\tfor (uint i = 0; i < length; i++) {\n\t\t\taddress troveManager = factory.troveManagers(i);\n\t\t\tIERC20 collateral = ITroveManager(troveManager).collateralToken();\n\t\t\ttroveManagersAndCollaterals[i] = [troveManager, address(collateral)];\n\t\t\tfor (uint x = 0; x < length; x++) {\n\t\t\t\tif (uniqueCollaterals[x] == address(collateral)) break;\n\t\t\t\tif (uniqueCollaterals[x] == address(0)) {\n\t\t\t\t\tuniqueCollaterals[x] = address(collateral);\n\t\t\t\t\tcollateralCount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollateral[] memory collateralMap = new Collateral[](collateralCount);\n\t\tfor (uint i = 0; i < collateralCount; i++) {\n\t\t\tcollateralMap[i].collateral = IERC20(uniqueCollaterals[i]);\n\t\t\tuint tmCollCount = 0;\n\t\t\taddress[] memory troveManagers = new address[](length);\n\t\t\tfor (uint x = 0; x < length; x++) {\n\t\t\t\tif (troveManagersAndCollaterals[x][1] == uniqueCollaterals[i]) {\n\t\t\t\t\ttroveManagers[tmCollCount] = troveManagersAndCollaterals[x][0];\n\t\t\t\t\ttmCollCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcollateralMap[i].troveManagers = new address[](tmCollCount);\n\t\t\tfor (uint x = 0; x < tmCollCount; x++) {\n\t\t\t\tcollateralMap[i].troveManagers[x] = troveManagers[x];\n\t\t\t}\n\t\t}\n\n\t\treturn collateralMap;\n\t}\n\n\t/**\n        @notice Returns a list of trove managers where `account` has an existing trove\n     */\n\tfunction getActiveTroveManagersForAccount(address account) external view returns (address[] memory) {\n\t\tuint256 length = factory.troveManagerCount();\n\t\taddress[] memory troveManagers = new address[](length);\n\t\tuint256 tmCount;\n\t\tfor (uint i = 0; i < length; i++) {\n\t\t\taddress troveManager = factory.troveManagers(i);\n\t\t\tif (ITroveManager(troveManager).getTroveStatus(account) > 0) {\n\t\t\t\ttroveManagers[tmCount] = troveManager;\n\t\t\t\ttmCount++;\n\t\t\t}\n\t\t}\n\t\tassembly {\n\t\t\tmstore(troveManagers, tmCount)\n\t\t}\n\t\treturn troveManagers;\n\t}\n}\n"
    },
    "contracts/helpers/TroveState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\n\ncontract TroveState {\n\tIBorrowerOperations public bo;\n\tITroveManager public tm;\n\tIStabilityPool public sp;\n\n\tstruct State {\n\t\tuint256 coll;\n\t\tuint256 debt;\n\t\tuint256 interest;\n\t\tuint256 MCR;\n\t\tuint256 ICR;\n\t\tuint256 CCR;\n\t\tuint256 TCR;\n\t\tuint256 price;\n\t\tuint256 maxCap;\n\t\tuint256 totalUSDMinted;\n\t\tuint256 spStaked;\n\t\tuint256 spWETHGains;\n\t\tuint256 spEsZebraGains;\n\t}\n\n\tconstructor(IBorrowerOperations _bo, ITroveManager _tm, IStabilityPool _sp) {\n\t\tbo = _bo;\n\t\ttm = _tm;\n\t\tsp = _sp;\n\t}\n\n\tfunction getState(address _borrower) public returns (State memory state) {\n\t\t(state.coll, state.debt) = tm.getTroveCollAndDebt(_borrower);\n\t\tstate.interest = tm.getTroveInterest(_borrower, state.debt);\n\t\tstate.MCR = tm.MCR();\n\t\tstate.CCR = tm.CCR();\n\t\tstate.TCR = bo.getTCR();\n\t\tstate.price = tm.fetchPrice();\n\t\tstate.totalUSDMinted = tm.getEntireSystemDebt();\n\t\tstate.spStaked = sp.getTotalZebraUSDDeposits();\n\t\tuint256[] memory collGains = sp.getDepositorCollateralGain(_borrower);\n\t\tif (collGains.length > 0) {\n\t\t\tstate.spWETHGains = collGains[0];\n\t\t}\n\t\tstate.spEsZebraGains = sp.claimableReward(_borrower);\n\t}\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITroveManager.sol\";\n\ninterface IBorrowerOperations {\n\tstruct SystemBalances {\n\t\tuint256[] collaterals;\n\t\tuint256[] debts;\n\t\tuint256[] prices;\n\t}\n\n\tenum BorrowerOperation {\n\t\topenTrove,\n\t\tcloseTrove,\n\t\tadjustTrove\n\t}\n\n\tevent BorrowingFeePaid(address indexed borrower, uint256 amount);\n\tevent CollateralConfigured(ITroveManager troveManager, IERC20 collateralToken);\n\tevent TroveCreated(address indexed _borrower, uint256 arrayIndex);\n\tevent TroveManagerRemoved(ITroveManager troveManager);\n\tevent TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, BorrowerOperation operation);\n\n\tfunction addColl(ITroveManager troveManager, address account, uint256 _collateralAmount, address _upperHint, address _lowerHint) external;\n\n\tfunction adjustTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collDeposit, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external;\n\n\tfunction closeTrove(ITroveManager troveManager, address account) external;\n\n\tfunction configureCollateral(ITroveManager troveManager, IERC20 collateralToken) external;\n\n\tfunction fetchBalances() external returns (SystemBalances memory balances);\n\n\tfunction getGlobalSystemBalances() external returns (uint256 totalPricedCollateral, uint256 totalDebt);\n\n\tfunction getTCR() external returns (uint256 globalTotalCollateralRatio);\n\n\tfunction openTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collateralAmount, uint256 _debtAmount, address _upperHint, address _lowerHint) external;\n\n\tfunction removeTroveManager(ITroveManager troveManager) external;\n\n\tfunction repayDebt(ITroveManager troveManager, address account, uint256 _debtAmount, address _upperHint, address _lowerHint) external;\n\n\tfunction setMinNetDebt(uint256 _minNetDebt) external;\n\n\tfunction withdrawColl(ITroveManager troveManager, address account, uint256 _collWithdrawal, address _upperHint, address _lowerHint) external;\n\n\tfunction withdrawDebt(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _debtAmount, address _upperHint, address _lowerHint) external;\n\n\tfunction factory() external view returns (address);\n\n\tfunction getCompositeDebt(uint256 _debt) external view returns (uint256);\n\n\tfunction minNetDebt() external view returns (uint256);\n\n\tfunction checkRecoveryMode(uint256 TCR) external pure returns (bool);\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IFactory {\n\t// commented values are suggested default parameters\n\tstruct DeploymentParams {\n\t\tuint256 minuteDecayFactor; // 999037758833783000  (half life of 12 hours)\n\t\tuint256 redemptionFeeFloor; // 1e18 / 1000 * 5  (0.5%)\n\t\tuint256 maxRedemptionFee; // 1e18  (100%)\n\t\tuint256 borrowingFeeFloor; // 1e18 / 1000 * 5  (0.5%)\n\t\tuint256 maxBorrowingFee; // 1e18 / 100 * 5  (5%)\n\t\tuint256 interestRateInBps; // 100 (1%)\n\t\tuint256 maxDebt;\n\t\tuint256 MCR; // 12 * 1e17  (120%)\n\t}\n\n\tevent NewDeployment(address collateral, address priceFeed, address troveManager, address sortedTroves);\n\n\tfunction deployNewInstance(address collateral, address priceFeed, address customTroveManagerImpl, address customSortedTrovesImpl, DeploymentParams calldata params) external;\n\n\tfunction setImplementations(address _troveManagerImpl, address _sortedTrovesImpl) external;\n\n\tfunction Zebra_CORE() external view returns (address);\n\n\tfunction borrowerOperations() external view returns (address);\n\n\tfunction debtToken() external view returns (address);\n\n\tfunction guardian() external view returns (address);\n\n\tfunction liquidationManager() external view returns (address);\n\n\tfunction owner() external view returns (address);\n\n\tfunction sortedTrovesImpl() external view returns (address);\n\n\tfunction stabilityPool() external view returns (address);\n\n\tfunction troveManagerCount() external view returns (uint256);\n\n\tfunction troveManagerImpl() external view returns (address);\n\n\tfunction troveManagers(uint256) external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILiquidationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface ILiquidationManager {\n\tevent Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _collGasCompensation, uint256 _debtGasCompensation);\n\tevent TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, uint8 _operation);\n\tevent TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, uint8 _operation);\n\n\tfunction batchLiquidateTroves(address troveManager, address[] calldata _troveArray) external;\n\n\tfunction enableTroveManager(address _troveManager) external;\n\n\tfunction liquidate(address troveManager, address borrower) external;\n\n\tfunction liquidateTroves(address troveManager, uint256 maxTrovesToLiquidate, uint256 maxICR) external;\n\n\tfunction CCR() external view returns (uint256);\n\n\tfunction DEBT_GAS_COMPENSATION() external view returns (uint256);\n\n\tfunction DECIMAL_PRECISION() external view returns (uint256);\n\n\tfunction PERCENT_DIVISOR() external view returns (uint256);\n\n\tfunction borrowerOperations() external view returns (address);\n\n\tfunction factory() external view returns (address);\n\n\tfunction stabilityPool() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IPyth.sol\";\n\ninterface IPriceFeed {\n\tstruct OracleRecord {\n\t\tIPyth pyth;\n\t\tuint32 decimals;\n\t\tuint32 heartbeat;\n\t\tbool isFeedWorking;\n\t}\n\n\tstruct PriceRecord {\n\t\tuint96 scaledPrice;\n\t\tuint32 timestamp;\n\t\tuint32 lastUpdated;\n\t}\n\n\tstruct FeedResponse {\n\t\tint64 price;\n\t\t// Confidence interval around the price\n\t\tuint64 conf;\n\t\t// Price exponent\n\t\tint32 expo;\n\t\t// Unix timestamp describing when the price was published\n\t\tuint publishTime;\n\t\tbool success;\n\t}\n\n\t// Custom Errors --------------------------------------------------------------------------------------------------\n\n\terror PriceFeed__InvalidFeedResponseError();\n\terror PriceFeed__FeedFrozenError();\n\terror PriceFeed__UnknownFeedError();\n\terror PriceFeed__HeartbeatOutOfBoundsError();\n\n\t// Events ---------------------------------------------------------------------------------------------------------\n\n\tevent NewOracleRegistered(address pyth);\n\tevent PriceFeedStatusUpdated(address oracle, bool isWorking);\n\tevent PriceRecordUpdated(uint256 _price);\n\n\tfunction fetchPrice(address _token) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPyth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IPyth {\n\tstruct Price {\n\t\t// Price\n\t\tint64 price;\n\t\t// Confidence interval around the price\n\t\tuint64 conf;\n\t\t// Price exponent\n\t\tint32 expo;\n\t\t// Unix timestamp describing when the price was published\n\t\tuint publishTime;\n\t}\n\n\tfunction getPrice(bytes32 id) external view returns (Price memory);\n\n\tfunction getPriceUnsafe(bytes32 id) external view returns (Price memory price);\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface ISortedTroves {\n\tevent NodeAdded(address _id, uint256 _NICR);\n\tevent NodeRemoved(address _id);\n\n\tfunction insert(address _id, uint256 _NICR, address _prevId, address _nextId) external;\n\n\tfunction reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external;\n\n\tfunction remove(address _id) external;\n\n\tfunction setAddresses(address _troveManagerAddress) external;\n\n\tfunction contains(address _id) external view returns (bool);\n\n\tfunction data() external view returns (address head, address tail, uint256 size);\n\n\tfunction findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (address, address);\n\n\tfunction getFirst() external view returns (address);\n\n\tfunction getLast() external view returns (address);\n\n\tfunction getNext(address _id) external view returns (address);\n\n\tfunction getPrev(address _id) external view returns (address);\n\n\tfunction getSize() external view returns (uint256);\n\n\tfunction isEmpty() external view returns (bool);\n\n\tfunction troveManager() external view returns (address);\n\n\tfunction validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStabilityPool {\n\tevent CollateralGainWithdrawn(address indexed _depositor, uint256[] _collateral);\n\tevent CollateralOverwritten(address oldCollateral, address newCollateral);\n\tevent DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n\tevent EpochUpdated(uint128 _currentEpoch);\n\tevent G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n\tevent P_Updated(uint256 _P);\n\tevent RewardClaimed(address indexed account, address indexed recipient, uint256 claimed);\n\tevent S_Updated(uint256 idx, uint256 _S, uint128 _epoch, uint128 _scale);\n\tevent ScaleUpdated(uint128 _currentScale);\n\tevent StabilityPoolZebraUSDBalanceUpdated(uint256 _newBalance);\n\tevent UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n\n\t// function claimCollateralGains(address recipient, uint256[] calldata collateralIndexes) external;\n\n\t// function claimReward(address recipient) external returns (uint256 amount);\n\n\tfunction enableCollateral(IERC20 _collateral) external;\n\n\tfunction offset(IERC20 collateral, uint256 _debtToOffset, uint256 _collToAdd) external;\n\n\tfunction provideToSP(uint256 _amount) external;\n\n\tfunction startCollateralSunset(IERC20 collateral) external;\n\n\tfunction withdrawFromSP(uint256 _amount) external;\n\n\tfunction DECIMAL_PRECISION() external view returns (uint256);\n\n\tfunction P() external view returns (uint256);\n\n\tfunction SCALE_FACTOR() external view returns (uint256);\n\n\tfunction SUNSET_DURATION() external view returns (uint128);\n\n\tfunction claimableReward(address _depositor) external view returns (uint256);\n\n\tfunction currentEpoch() external view returns (uint128);\n\n\tfunction currentScale() external view returns (uint128);\n\n\tfunction depositSnapshots(address) external view returns (uint256 P, uint256 G, uint128 scale, uint128 epoch);\n\n\tfunction depositSums(address, uint256) external view returns (uint256);\n\n\tfunction epochToScaleToG(uint128, uint128) external view returns (uint256);\n\n\tfunction epochToScaleToSums(uint128, uint128, uint256) external view returns (uint256);\n\n\tfunction factory() external view returns (address);\n\n\tfunction getCompoundedDeposit(address _depositor) external view returns (uint256);\n\n\tfunction getDepositorCollateralGain(address _depositor) external view returns (uint256[] memory collateralGains);\n\n\tfunction getTotalZebraUSDDeposits() external view returns (uint256);\n\n\tfunction lastDebtLossError_Offset() external view returns (uint256);\n\n\tfunction lastEsZebraError() external view returns (uint256);\n\n\tfunction liquidationManager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IZebraBase.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./IPriceFeed.sol\";\n\ninterface ITroveManager is IZebraBase {\n\t// Store the necessary data for a trove\n\tstruct Trove {\n\t\tuint256 debt;\n\t\tuint256 coll;\n\t\tuint256 stake;\n\t\tStatus status;\n\t\tuint128 arrayIndex;\n\t}\n\n\tstruct RedemptionTotals {\n\t\tuint256 remainingDebt;\n\t\tuint256 totalDebtToRedeem;\n\t\tuint256 totalCollateralDrawn;\n\t\tuint256 totalInterest;\n\t\tuint256 collateralFee;\n\t\tuint256 collateralToSendToRedeemer;\n\t\tuint256 decayedBaseRate;\n\t\tuint256 price;\n\t\tuint256 totalDebtSupplyAtStart;\n\t}\n\n\tstruct SingleRedemptionValues {\n\t\tuint256 debtLot;\n\t\tuint256 collateralLot;\n\t\tuint256 interestLot;\n\t\tbool cancelledPartial;\n\t}\n\n\t// Object containing the collateral and debt snapshots for a given active trove\n\tstruct RewardSnapshot {\n\t\tuint256 collateral;\n\t\tuint256 debt;\n\t\tuint256 interest;\n\t}\n\n\tenum TroveManagerOperation {\n\t\tapplyPendingRewards,\n\t\tliquidateInNormalMode,\n\t\tliquidateInRecoveryMode,\n\t\tredeemCollateral\n\t}\n\n\tenum Status {\n\t\tnonExistent,\n\t\tactive,\n\t\tclosedByOwner,\n\t\tclosedByLiquidation,\n\t\tclosedByRedemption\n\t}\n\n\tevent InsterstPaid(address _account, address _borrower, uint256 _interest);\n\tevent TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, TroveManagerOperation _operation);\n\tevent Redemption(uint256 _attemptedDebtAmount, uint256 _actualDebtAmount, uint256 _collateralSent, uint256 _InterestDebt, uint256 _collateralFee);\n\tevent BaseRateUpdated(uint256 _baseRate);\n\tevent LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n\tevent TotalStakesUpdated(uint256 _newTotalStakes);\n\tevent SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\n\tevent LTermsUpdated(uint256 _L_collateral, uint256 _L_debt);\n\tevent TroveSnapshotsUpdated(uint256 _L_collateral, uint256 _L_debt, uint256 _L_Interest_Debt);\n\tevent TroveIndexUpdated(address _borrower, uint256 _newIndex);\n\tevent CollateralSent(address _to, uint256 _amount);\n\tevent RewardClaimed(address indexed account, address indexed recipient, uint256 claimed);\n\n\tfunction addCollateralSurplus(address borrower, uint256 collSurplus) external;\n\n\tfunction applyPendingRewards(address _borrower) external returns (uint256 coll, uint256 debt);\n\n\tfunction claimCollateral(address _receiver) external;\n\n\tfunction closeTrove(address _borrower, address _receiver, uint256 collAmount, uint256 debtAmount) external;\n\n\tfunction closeTroveByLiquidation(address _borrower) external;\n\n\tfunction decayBaseRateAndGetBorrowingFee(uint256 _debt) external returns (uint256);\n\n\tfunction decreaseDebtAndSendCollateral(address account, uint256 debt, uint256 coll) external;\n\n\tfunction finalizeLiquidation(address _liquidator, uint256 _debt, uint256 _coll, uint256 _collSurplus, uint256 _debtGasComp, uint256 _collGasComp, uint256 _interest) external;\n\n\tfunction getEntireSystemBalances() external returns (uint256, uint256, uint256);\n\n\tfunction movePendingTroveRewardsToActiveBalances(uint256 _debt, uint256 _collateral) external;\n\n\tfunction openTrove(address _borrower, uint256 _collateralAmount, uint256 _compositeDebt, uint256 NICR, address _upperHint, address _lowerHint) external returns (uint256 stake, uint256 arrayIndex);\n\n\tfunction redeemCollateral(uint256 _debtAmount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint256 _partialRedemptionHintNICR, uint256 _maxIterations, uint256 _maxFeePercentage) external;\n\n\tfunction setAddresses(address _priceFeedAddress, address _sortedTrovesAddress, IERC20 _collateralToken) external;\n\n\tfunction setParameters(uint256 _minuteDecayFactor, uint256 _redemptionFeeFloor, uint256 _maxRedemptionFee, uint256 _borrowingFeeFloor, uint256 _maxBorrowingFee, uint256 _maxSystemDebt, uint256 _MCR, uint32 _interestRate) external;\n\n\tfunction setPaused(bool _paused) external;\n\n\tfunction setPriceFeed(address _priceFeedAddress) external;\n\n\tfunction updateTroveFromAdjustment(bool _isDebtIncrease, uint256 _debtChange, uint256 _netDebtChange, bool _isCollIncrease, uint256 _collChange, address _upperHint, address _lowerHint, address _borrower, address _receiver) external returns (uint256, uint256, uint256);\n\n\tfunction fetchPrice() external returns (uint256);\n\n\tfunction distributeInterestDebt() external returns (uint256);\n\n\tfunction repayInterest(address _account, address _borrower, uint256 _debt) external;\n\n\tfunction BOOTSTRAP_PERIOD() external view returns (uint256);\n\n\tfunction L_collateral() external view returns (uint256);\n\n\tfunction L_debt() external view returns (uint256);\n\n\tfunction MCR() external view returns (uint256);\n\n\tfunction getTrove(address _borrower) external view returns (Trove memory);\n\n\tfunction baseRate() external view returns (uint256);\n\n\tfunction borrowerOperationsAddress() external view returns (address);\n\n\tfunction borrowingFeeFloor() external view returns (uint256);\n\n\tfunction collateralToken() external view returns (IERC20);\n\n\tfunction defaultedCollateral() external view returns (uint256);\n\n\tfunction defaultedDebt() external view returns (uint256);\n\n\tfunction getBorrowingFee(uint256 _debt) external view returns (uint256);\n\n\tfunction getBorrowingFeeWithDecay(uint256 _debt) external view returns (uint256);\n\n\tfunction getBorrowingRate() external view returns (uint256);\n\n\tfunction getBorrowingRateWithDecay() external view returns (uint256);\n\n\tfunction getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);\n\n\tfunction getEntireDebtAndColl(address _borrower) external view returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollateralReward);\n\n\tfunction getEntireSystemColl() external view returns (uint256);\n\n\tfunction getEntireSystemDebt() external view returns (uint256);\n\n\tfunction getGlobalSystemDebt() external view returns (uint256);\n\n\tfunction getTroveInterest(address _borrower, uint256 _debt) external view returns (uint256);\n\n\tfunction getRedemptionICR(address _borrower, uint256 _price) external view returns (uint256);\n\n\tfunction getNominalICR(address _borrower) external view returns (uint256);\n\n\tfunction getPendingCollAndDebtRewards(address _borrower) external view returns (uint256, uint256);\n\n\tfunction getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256);\n\n\tfunction getRedemptionRate() external view returns (uint256);\n\n\tfunction getRedemptionRateWithDecay() external view returns (uint256);\n\n\tfunction getTotalActiveCollateral() external view returns (uint256);\n\n\tfunction getTotalActiveDebt() external view returns (uint256);\n\n\tfunction getTroveCollAndDebt(address _borrower) external view returns (uint256 coll, uint256 debt);\n\n\tfunction getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);\n\n\tfunction getTroveOwnersCount() external view returns (uint256);\n\n\tfunction getTroveStake(address _borrower) external view returns (uint256);\n\n\tfunction getTroveStatus(address _borrower) external view returns (uint256);\n\n\tfunction hasPendingRewards(address _borrower) external view returns (bool);\n\n\tfunction lastCollateralError_Redistribution() external view returns (uint256);\n\n\tfunction lastDebtError_Redistribution() external view returns (uint256);\n\n\tfunction lastFeeOperationTime() external view returns (uint256);\n\n\tfunction liquidationManager() external view returns (address);\n\n\tfunction maxBorrowingFee() external view returns (uint256);\n\n\tfunction maxRedemptionFee() external view returns (uint256);\n\n\tfunction maxSystemDebt() external view returns (uint256);\n\n\tfunction minuteDecayFactor() external view returns (uint256);\n\n\tfunction paused() external view returns (bool);\n\n\tfunction redemptionFeeFloor() external view returns (uint256);\n\n\tfunction getRewardSnapshots(address) external view returns (RewardSnapshot memory);\n\n\tfunction priceFeed() external view returns (IPriceFeed);\n\n\tfunction sortedTroves() external view returns (ISortedTroves);\n\n\tfunction sunsetting() external view returns (bool);\n\n\tfunction surplusBalances(address) external view returns (uint256);\n\n\tfunction systemDeploymentTime() external view returns (uint256);\n\n\tfunction totalCollateralSnapshot() external view returns (uint256);\n\n\tfunction totalStakes() external view returns (uint256);\n\n\tfunction totalStakesSnapshot() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZebraBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IZebraBase {\n\tfunction DECIMAL_PRECISION() external view returns (uint256);\n\n\t// Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n\tfunction CCR() external view returns (uint256); // 200%\n\n\t// Amount of debt to be locked in gas pool on opening troves\n\tfunction DEBT_GAS_COMPENSATION() external view returns (uint256);\n\n\tfunction PERCENT_DIVISOR() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZebraCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IZebraCore {\n\tevent FeeReceiverSet(address feeReceiver);\n\tevent GuardianSet(address guardian);\n\tevent NewOwnerAccepted(address oldOwner, address owner);\n\tevent NewOwnerCommitted(address owner, address pendingOwner, uint256 deadline);\n\tevent NewOwnerRevoked(address owner, address revokedOwner);\n\tevent Paused();\n\tevent PriceFeedSet(address priceFeed);\n\tevent Unpaused();\n\n\tfunction acceptTransferOwnership() external;\n\n\tfunction commitTransferOwnership(address newOwner) external;\n\n\tfunction revokeTransferOwnership() external;\n\n\tfunction setFeeReceiver(address _feeReceiver) external;\n\n\tfunction setGuardian(address _guardian) external;\n\n\tfunction setPaused(bool _paused) external;\n\n\tfunction setPriceFeed(address _priceFeed) external;\n\n\tfunction OWNERSHIP_TRANSFER_DELAY() external view returns (uint256);\n\n\tfunction feeReceiver() external view returns (address);\n\n\tfunction guardian() external view returns (address);\n\n\tfunction owner() external view returns (address);\n\n\tfunction ownershipTransferDeadline() external view returns (uint256);\n\n\tfunction paused() external view returns (bool);\n\n\tfunction pendingOwner() external view returns (address);\n\n\tfunction startTime() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZebraUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IZebraUSD {\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\tevent MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\tevent ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint256 _amount);\n\tevent RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\tevent SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint256 _amount);\n\tevent SetMinDstGas(uint16 _dstChainId, uint16 _type, uint256 _minDstGas);\n\tevent SetPrecrime(address precrime);\n\tevent SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n\tevent SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n\tevent SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\tfunction burn(address _account, uint256 _amount) external;\n\n\tfunction burnWithGasCompensation(address _account, uint256 _amount) external returns (bool);\n\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n\tfunction enableTroveManager(address _troveManager) external;\n\n\tfunction flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\n\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n\n\tfunction increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n\tfunction lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n\n\tfunction mint(address _account, uint256 _amount) external;\n\n\tfunction mintWithGasCompensation(address _account, uint256 _amount) external returns (bool);\n\n\tfunction nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n\n\tfunction permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n\tfunction renounceOwnership() external;\n\n\tfunction returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external;\n\n\tfunction sendToSP(address _sender, uint256 _amount) external;\n\n\tfunction setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\n\n\tfunction setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint256 _minGas) external;\n\n\tfunction setPayloadSizeLimit(uint16 _dstChainId, uint256 _size) external;\n\n\tfunction setPrecrime(address _precrime) external;\n\n\tfunction setReceiveVersion(uint16 _version) external;\n\n\tfunction setSendVersion(uint16 _version) external;\n\n\tfunction setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external;\n\n\tfunction setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external;\n\n\tfunction setUseCustomAdapterParams(bool _useCustomAdapterParams) external;\n\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferOwnership(address newOwner) external;\n\n\tfunction retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external payable;\n\n\tfunction sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint256 _amount, address _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n\tfunction DEBT_GAS_COMPENSATION() external view returns (uint256);\n\n\tfunction DEFAULT_PAYLOAD_SIZE_LIMIT() external view returns (uint256);\n\n\tfunction FLASH_LOAN_FEE() external view returns (uint256);\n\n\tfunction NO_EXTRA_GAS() external view returns (uint256);\n\n\tfunction PT_SEND() external view returns (uint16);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\tfunction borrowerOperationsAddress() external view returns (address);\n\n\tfunction circulatingSupply() external view returns (uint256);\n\n\tfunction decimals() external view returns (uint8);\n\n\tfunction domainSeparator() external view returns (bytes32);\n\n\tfunction estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint256 _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint256 nativeFee, uint256 zroFee);\n\n\tfunction factory() external view returns (address);\n\n\tfunction failedMessages(uint16, bytes calldata, uint64) external view returns (bytes32);\n\n\tfunction flashFee(address token, uint256 amount) external view returns (uint256);\n\n\tfunction gasPool() external view returns (address);\n\n\tfunction getConfig(uint16 _version, uint16 _chainId, address, uint256 _configType) external view returns (bytes memory);\n\n\tfunction getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory);\n\n\tfunction isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n\tfunction lzEndpoint() external view returns (address);\n\n\tfunction maxFlashLoan(address token) external view returns (uint256);\n\n\tfunction minDstGasLookup(uint16, uint16) external view returns (uint256);\n\n\tfunction name() external view returns (string memory);\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction owner() external view returns (address);\n\n\tfunction payloadSizeLimitLookup(uint16) external view returns (uint256);\n\n\tfunction permitTypeHash() external view returns (bytes32);\n\n\tfunction precrime() external view returns (address);\n\n\tfunction stabilityPoolAddress() external view returns (address);\n\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n\tfunction symbol() external view returns (string memory);\n\n\tfunction token() external view returns (address);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction troveManager(address) external view returns (bool);\n\n\tfunction trustedRemoteLookup(uint16) external view returns (bytes memory);\n\n\tfunction useCustomAdapterParams() external view returns (bool);\n\n\tfunction version() external view returns (string memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}